<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Squid Game - Yeonghee</title>

    <!-- Favicon -->
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🦑</text></svg>"
    />

    <!-- Meta Tags -->
    <meta
      name="description"
      content="Play the exciting Squid Game clicking game! Click to earn coins and level up in this thrilling game experience."
    />
    <meta
      name="keywords"
      content="squid game, clicking game, online game, coins, level up"
    />
    <meta name="author" content="Squid Game" />

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content=" Squid Game - Yeonghee Game" />
    <meta
      property="og:description"
      content="Play as Yeonghee in the ultimate Squid Game challenge! Tap to survive and collect coins."
    />
    <meta
      property="og:image"
      content="https://squid-game-m29i-123.vercel.app/images/thumbnail.png"
    />
    <meta property="og:image:width" content="475" />
    <meta property="og:image:height" content="220" />
    <meta property="og:url" content="https://squid-game-m29i-123.vercel.app/" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Squid Game" />

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content=" Squid Game - Yeonghee Game" />
    <meta
      name="twitter:description"
      content="Play as Yeonghee in the ultimate Squid Game challenge!"
    />
    <meta
      name="twitter:image"
      content="https://squid-game-m29i-123.vercel.app/images/thumbnail.png"
    />

    <!-- Telegram Mini App Meta Tags -->
    <meta
      name="telegram:image"
      content="https://squid-game-m29i-123.vercel.app/images/thumbnail.png"
    />
    <meta name="telegram:title" content=" Squid Game - Yeonghee" />
    <meta
      name="telegram:description"
      content="Tap to play Squid Game as Yeonghee!"
    />

    <!-- Telegram WebApp Script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Gugi&display=swap"
      rel="stylesheet"
    />
    <style>
      .gradient-bg {
        background: linear-gradient(
          360deg,
          rgba(211, 47, 181, 0) 3.4%,
          #250a1f 98.64%
        );
      }

      .card-bg {
        background: radial-gradient(
          50% 50% at 50% 50%,
          #450832 0%,
          #2e032c 100%
        );
        border: 1px solid rgba(215, 12, 163, 0.3);
        box-shadow: inset 0px 1px 4px 0px rgba(70, 13, 55, 0.69);
      }

      /* Custom Progress Bar Styles */
      .custom-progress-bg {
        background-color: #2e032c;
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
      }

      .custom-progress-fill {
        background: linear-gradient(
          90deg,
          #ff6b8b 0%,
          #ff4081 50%,
          #ff6b8b 100%
        );
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease-in-out;
        position: relative;
        box-shadow: 0 0 8px rgba(255, 107, 139, 0.4);
      }

      .custom-progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(255, 255, 255, 0.3) 50%,
          transparent 100%
        );
        animation: shimmer 2s infinite;
      }

      .custom-progress-fill::before {
        content: "";
        position: absolute;
        top: 1px;
        left: 1px;
        right: 1px;
        height: 40%;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.4) 0%,
          rgba(255, 255, 255, 0.1) 100%
        );
        border-radius: 3px;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }

        50% {
          transform: translateX(100%);
        }

        100% {
          transform: translateX(200%);
        }
      }

      .progress-interactive {
        cursor: pointer;
      }

      .progress-interactive:hover .custom-progress-fill {
        box-shadow: 0 0 12px rgba(255, 107, 139, 0.6);
      }

      body {
        font-family: "Gugi", sans-serif;
      }

      /* Character and Sole Press Animation */
      .character-container {
        transition: transform 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        z-index: 50; /* Ensure character is above sole */
      }

      .character-container.pressed {
        transform: translateY(6px);
      }

      #sole {
        transition: transform 0.08s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        z-index: 10; /* Lower than character */
      }

      #sole.pressed {
        transform: translateY(8px);
      }

      /* Light Effect Animation */
      .light-effect {
        position: absolute;
        bottom: -145px;
        left: 50%;
        transform: translateX(-49.5%);
        width: 840px;
        height: 820px;
        background-image: url("./image/light.png");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        opacity: 0;
        z-index: 1; /* Below everything else */
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .light-effect.show {
        opacity: 1;
      }

      /* Coin Flying Animation */
      @keyframes coinFly {
        0% {
          transform: translate(0, 0) scale(0.8) rotate(0deg);
          opacity: 0;
        }
        10% {
          transform: translate(0, -30px) scale(1.8) rotate(45deg);
          opacity: 1;
        }
        50% {
          transform: translate(
              calc(var(--tx) * 0.5),
              calc(var(--ty) * 0.5 - 80px)
            )
            scale(1.5) rotate(180deg);
          opacity: 0.9;
        }
        80% {
          transform: translate(calc(var(--tx) * 0.8), calc(var(--ty) * 0.8))
            scale(1.2) rotate(270deg);
          opacity: 0.7;
        }
        100% {
          transform: translate(var(--tx), var(--ty)) scale(1) rotate(360deg);
          opacity: 0;
        }
      }

      .flying-coin {
        position: fixed;
        width: 35px;
        height: 35px;
        background: url("./image/money.svg") no-repeat center;
        background-size: contain;
        pointer-events: none;
        z-index: 9999;
        animation: coinFly 2.5s ease-out forwards;
      }

      /* Level Up Popup Styles */
      .level-up-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .level-up-popup.show {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .level-up-content {
        background: linear-gradient(135deg, #2e032c 0%, #450832 100%);
        border: 2px solid rgba(215, 12, 163, 0.5);
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        max-width: 300px;
        width: 90%;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      }

      .level-up-emoji {
        font-size: 48px;
        margin-bottom: 15px;
      }

      .level-up-title {
        font-size: 24px;
        font-weight: bold;
        color: #ff6b8b;
        margin-bottom: 10px;
      }

      .level-up-description {
        color: white;
        margin-bottom: 20px;
        font-size: 14px;
      }

      .level-up-button {
        background: linear-gradient(90deg, #ff6b8b 0%, #ff4081 100%);
        border: none;
        border-radius: 10px;
        padding: 12px 30px;
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s ease;
      }

      .level-up-button:hover {
        transform: scale(1.05);
      }

      /* Tap area styles */
      .tap-area {
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      /* Flash effect for tap feedback */
      @keyframes flash {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
        100% {
          opacity: 1;
        }
      }

      .flash {
        animation: flash 0.2s ease-out;
      }

      /* Progress Bar Styles from index.html */
      .progress-bar {
        background: linear-gradient(90deg, #e45f90 0%, #f06292 100%);
        height: 8px;
      }

      .progress-icon {
        position: absolute;
        border-radius: 0.5px;
        background: linear-gradient(0deg, #bac1d6 0.01%, #ffffff 99.98%);
        width: 5.5px;
        height: 14px;
        top: -1px;
        transition: left 0.3s ease;
      }

      .level-bars {
        background-color: #facc15;
        height: 12px;
      }

      /* HP Progress Container */
      .hp-progress-container {
        position: relative;
        width: 100%;
        height: 12px;
        background: rgba(215, 12, 163, 0.42);
        border-radius: 4px;
        overflow: hidden;
      }

      /* HP Level Progress Container */
      .hp-level-progress-container {
        position: relative;
        width: 100%;
        height: 12px;
        background: rgba(215, 12, 163, 0.42);
        border-radius: 4px;
        overflow: hidden;
      }

      /* LP Level Progress Container */
      .lp-level-progress-container {
        position: relative;
        width: 100%;
        height: 12px;
        background: rgba(215, 12, 163, 0.42);
        border-radius: 4px;
        overflow: hidden;
      }

      /* Target indicator for coin flights */
      .coin-target-indicator {
        box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        border: 1px solid rgba(255, 215, 0, 0.4);
        animation: targetPulse 2s infinite;
      }

      @keyframes targetPulse {
        0% {
          box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }
        50% {
          box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }
        100% {
          box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }
      }

      /* Level Progress Icon */
      .level-progress-icon {
        position: absolute;
        border-radius: 0.5px;
        background: linear-gradient(0deg, #bac1d6 0.01%, #ffffff 99.98%);
        width: 5.5px;
        height: 14px;
        top: -1px;
        transition: left 0.3s ease;
      }

      /* Mobile adjustments */
      @media screen and (max-width: 428px) {
        .level-bars {
          height: 8px;
        }

        .progress-icon {
          height: 12px;
        }

        .level-progress-icon {
          height: 12px;
        }
      }

      

      /* Auto Earn Button Styles */
      #auto-earn-button {
        transition: all 0.3s ease;
        cursor: pointer;
        z-index: 100;
        position: relative;
      }

      #auto-earn-button:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px rgba(255, 107, 139, 0.4);
      }

      #auto-earn-button.active {
        background: linear-gradient(
          135deg,
          #ff6b8b 0%,
          #ff4081 100%
        ) !important;
        border: 2px solid #ff6b8b !important;
        box-shadow: 0 0 20px rgba(255, 107, 139, 0.6),
          inset 0 0 10px rgba(255, 255, 255, 0.2) !important;
        animation: pulse-glow 2s infinite;
      }

      #auto-earn-button.active img {
        filter: brightness(1.2) drop-shadow(0 0 5px rgba(255, 255, 255, 0.8));
      }

      @keyframes pulse-glow {
        0% {
          box-shadow: 0 0 20px rgba(255, 107, 139, 0.6),
            inset 0 0 10px rgba(255, 255, 255, 0.2);
        }
        50% {
          box-shadow: 0 0 30px rgba(255, 107, 139, 0.8),
            inset 0 0 15px rgba(255, 255, 255, 0.3);
        }
        100% {
          box-shadow: 0 0 20px rgba(255, 107, 139, 0.6),
            inset 0 0 10px rgba(255, 255, 255, 0.2);
        }
      }

      /* Visual Effects Functions */
      .show-floating-text {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #ffd93d;
        font-size: 24px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 10001;
        animation: floatUp 2s ease-out forwards;
      }

      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0px) scale(1);
        }
        50% {
          opacity: 1;
          transform: translateY(-30px) scale(1.1);
        }
        100% {
          opacity: 0;
          transform: translateY(-60px) scale(0.8);
        }
      }

      .show-multiplier-effect {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #ffd93d;
        font-size: 24px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 10001;
        animation: floatUp 2s ease-out forwards;
      }

      /* Bottom Navigation Active State */
      .nav-item {
        transition: all 0.3s ease;
        cursor: pointer;
        padding: 12px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 48px;
        min-height: 48px;
      }

      .nav-item.active {
        background: rgba(255, 107, 139, 0.2);
        box-shadow: 0 0 15px rgba(255, 107, 139, 0.4);
        border: 1px solid rgba(255, 107, 139, 0.3);
      }

      .nav-item.active img {
        filter: brightness(1.5) drop-shadow(0 0 8px rgba(255, 107, 139, 0.8));
        transform: scale(1.2);
      }

      .nav-item:hover {
        background: rgba(255, 107, 139, 0.1);
        transform: scale(1.05);
      }

      .nav-item img {
        width: 24px;
        height: 24px;
        transition: all 0.3s ease;
      }
    </style>
  </head>

  <body class="bg-gray-900 min-h-screen">
    <div
      class="w-[375px] relative h-[667px] rounded-[20px] mx-auto gradient-bg p-[16px]"
    >
      <img
        class="absolute rounded-[20px] top-0 left-0 z-[-1] bottom-0 right-0"
        src="./image/bg.png"
        alt=""
      />
      <div class="flex flex-col gap-[8px]">
        <div class="flex justify-between items-center">
          <div
            class="flex w-[165.5px] h-[30px] px-[4px] pr-[12px] py-[4px] gap-[8px] rounded-full card-bg items-center"
          >
            <img src="./image/ruby.svg" class="w-[20px]" alt="" />

            <span
              id="coin-count"
              class="gugi-font text-[14px] leading-[22px] tracking-[0%] align-middle text-white"
              >0</span
            >
          </div>

          <div
            class="flex w-[165.5px] h-[30px] px-[4px] pr-[12px] py-[4px] gap-[8px] rounded-full card-bg items-center"
          >
            <img src="./image/money.svg" alt="" />

            <span
              id="coin-earn"
              class="gugi-font text-[14px] leading-[22px] tracking-[0%] align-middle text-white"
              >0</span
            >
          </div>
        </div>

        <div
          class="card-bg gradient-bg p-[12px] rounded-[20px] w-full h-[142.5px]"
        >
          <div class="flex flex-col gap-[8px]">
            <div class="flex justify-between">
              <div class="flex flex-col gap-[10px] w-[228px]">
                <div class="flex justify-between">
                  <p
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-[#FF6B8B]"
                  >
                    HP
                  </p>
                  <p
                    id="hp-display"
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
                  >
                    100/100
                  </p>
                </div>
                <!-- HP Progress Bar -->
                <div class="hp-progress-container">
                  <div
                    class="progress-bar"
                    id="hp-bar"
                    style="width: 100%; transition: width 0.3s ease-in-out"
                  ></div>
                  <div class="progress-icon" style="left: 100%"></div>
                </div>
              </div>
              <div
                class="w-[63px] h-[52px] bg-[rgba(252,55,102,0.13)] flex flex-col gap-[4px] items-center justify-center rounded-[8px]"
              >
                <img class="w-[16px] h-[16px]" src="./image/money.png" alt="" />
                <p
                  id="total-coins"
                  class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
                >
                  0
                </p>
              </div>
            </div>
            <img src="./image/divider.svg" alt="" />
            <div class="flex justify-between items-center">
              <div class="w-[143px] flex flex-col gap-[9px]">
                <div class="flex justify-between">
                  <p
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-[#FF6B8B]"
                  >
                    HP lv
                  </p>
                  <p
                    id="hp-level-display"
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
                  >
                    1/100
                  </p>
                </div>

                <!-- HP Level Progress Bar -->
                <div class="hp-level-progress-container">
                  <div
                    class="level-bars"
                    id="hp-level-bar"
                    style="width: 0%; transition: width 0.3s ease-in-out"
                  ></div>
                  <div class="level-progress-icon" style="left: 0%"></div>
                </div>
              </div>

              <div class="w-[143px] flex flex-col gap-[9px]">
                <div class="flex justify-between">
                  <p
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-[#FF6B8B]"
                  >
                    MT lv
                  </p>
                  <p
                    id="lp-level-display"
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
                  >
                    1/100
                  </p>
                </div>

                <!-- LP Level Progress Bar -->
                <div class="lp-level-progress-container">
                  <div
                    class="level-bars"
                    id="lp-level-bar"
                    style="width: 0%; transition: width 0.3s ease-in-out"
                  ></div>
                  <div class="level-progress-icon" style="left: 0%"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="w-full flex justify-end">
          <div
            class="card-bg gradient-bg w-[85px] py-[8px] px-[12px] flex flex-col gap-[8px] rounded-lg"
          >
            <p
              class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
            >
              Events
            </p>
            <img class="w-[61px] h-[61px]" src="./image/gift.png" alt="" />
          </div>
        </div>
      </div>
      <div class="absolute bottom-[-20px] left-[-12px] p-[10px]">
        <div class="relative flex flex-col justify-between items-center">
          <div
            class="absolute top-[-150px] left-[20px] right-0 flex justify-center character-container"
          >
            <img
              id="younghee"
              class="w-[149px] h-[224px] tap-area"
              src="./image/character.png"
              alt=""
            />
          </div>
          <div class="relative">
            <!-- Light effect element -->
            <div id="light-effect" class="light-effect"></div>
            <img id="sole" class="tap-area" src="./image/sole1.png" alt="" />
          </div>
        </div>
      </div>
      <div
        id="bottom-navigation"
        class="absolute bottom-[-110px] gradient-bg card-bg w-[360px] h-[72px] rounded-full p-[24px] flex justify-center items-center"
      >
        <ul class="flex justify-between items-center gap-[24px] w-full">
          <li class="nav-item active" id="nav-earn">
            <img src="./image/earn.svg" alt="" />
          </li>
          <li class="nav-item" id="nav-exchange">
            <img src="./image/exchange.svg" alt="" />
          </li>
          <li class="nav-item" id="nav-boost">
            <img src="./image/boost.svg" alt="" />
          </li>
          <li class="nav-item" id="nav-point">
            <img src="./image/point.svg" alt="" />
          </li>
        </ul>
      </div>
      <div
        class="absolute bottom-[-20px] right-[16px] flex flex-col items-center justify-center"
      >
        <button
          id="auto-earn-button"
          class="gradient-bg card-bg w-[48px] h-[48px] rounded-lg flex items-center justify-center"
        >
          <img src="./image/button.svg" alt="" />
        </button>
        <p
          class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-[#FF6B8B]"
        >
          Auto earn
        </p>
      </div>
    </div>

      
      </div>
    </div>

    <!-- Level Up Popup -->
    <div id="level-up-popup" class="level-up-popup">
      <div class="level-up-content">
        <div class="level-up-emoji">🎉</div>
        <div class="level-up-text-container">
          <div class="level-up-title">Level Up!</div>
          <div class="level-up-description">
            New rewards unlocked and stronger power await you.
          </div>
        </div>
        <button
          id="level-up-confirm-btn"
          class="level-up-button"
          onclick="closeLevelUpPopup()"
        >
          <span class="level-up-button-text">Confirm</span>
        </button>
      </div>
    </div>

    <script>
      // =====================
      // 0. Telegram Integration & API Sync
      // =====================

      // Get Telegram user ID from URL parameters or Telegram WebApp
      let telegramUserId = null;

      function getTelegramUserId() {
        // First, try to get from localStorage (persistent)
        const savedUserId = localStorage.getItem("telegramUserId");
        if (savedUserId && !savedUserId.startsWith("demo_")) {
          telegramUserId = savedUserId;
          console.log("📱 Telegram User ID from localStorage:", telegramUserId);
          return telegramUserId;
        }

        // Try to get from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const userIdFromUrl = urlParams.get("userId");

        if (userIdFromUrl) {
          telegramUserId = userIdFromUrl;
          localStorage.setItem("telegramUserId", telegramUserId);
          console.log("📱 Telegram User ID from URL:", telegramUserId);
          return telegramUserId;
        }

        // Try to get from Telegram WebApp API
        if (window.Telegram && window.Telegram.WebApp) {
          const webApp = window.Telegram.WebApp;
          console.log("🔍 Telegram WebApp available:", webApp);
          console.log("🔍 WebApp initData:", webApp.initData);
          console.log("🔍 WebApp initDataUnsafe:", webApp.initDataUnsafe);

          if (webApp.initDataUnsafe && webApp.initDataUnsafe.user) {
            telegramUserId = webApp.initDataUnsafe.user.id.toString();
            localStorage.setItem("telegramUserId", telegramUserId);
            console.log("📱 Telegram User ID from WebApp:", telegramUserId);
            console.log("👤 User info:", webApp.initDataUnsafe.user);
            return telegramUserId;
          }
        }

        // Check if we have a saved demo ID
        if (savedUserId && savedUserId.startsWith("demo_")) {
          telegramUserId = savedUserId;
          console.log("📱 Using saved demo Telegram User ID:", telegramUserId);
          return telegramUserId;
        }

        // Fallback: generate a temporary ID for testing
        telegramUserId = "demo_" + Math.random().toString(36).substr(2, 9);
        localStorage.setItem("telegramUserId", telegramUserId);
        console.log("📱 Generated new demo Telegram User ID:", telegramUserId);
        return telegramUserId;
      }

      // API functions for syncing with server
      async function syncGameStateToServer(gameState) {
        if (!telegramUserId) return;

        try {
          const response = await fetch(`/api/sync/${telegramUserId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(gameState),
          });

          if (response.ok) {
            const result = await response.json();
            console.log("✅ Game state synced to server:", result);
          } else {
            console.error("❌ Failed to sync game state:", response.statusText);
          }
        } catch (error) {
          console.error("❌ Error syncing game state:", error);
        }
      }

      async function loadGameStateFromServer() {
        if (!telegramUserId) return null;

        try {
          const response = await fetch(`/api/user/${telegramUserId}`);

          if (response.ok) {
            const result = await response.json();
            if (result.success && result.data) {
              console.log("📥 Game state loaded from server:", result.data);

              // Convert server data format to client format
              return {
                level: result.data.level,
                hp: result.data.hp,
                coinCount: result.data.ruby,
                coinEarn: result.data.coins,
                lastRecover: result.data.lastRecover,
                lastZeroHP: result.data.lastZeroHP,
              };
            }
          }
        } catch (error) {
          console.error("❌ Error loading game state from server:", error);
        }

        return null;
      }

      // =====================
      // 1. Game Configuration - 100 Levels
      // =====================

      // Level up requirements (same as index.html)
      const LEVEL_UP_REQUIREMENTS = [
        3200,
        5200,
        7500,
        10100,
        13000,
        16200,
        19600,
        23300,
        27400,
        31700, // 1-10
        48400,
        55000,
        62000,
        69200,
        76800,
        84900,
        93400,
        102200,
        111400,
        121000, // 11-20
        163700,
        176700,
        190100,
        204000,
        218400,
        233300,
        248700,
        264500,
        280800,
        297600, // 21-30
        389700,
        423400,
        458200,
        494200,
        531400,
        569700,
        609200,
        649800,
        691500,
        734400, // 31-40
        908200,
        960900,
        1015100,
        1070500,
        1127300,
        1185400,
        1244900,
        1305700,
        1367900,
        0, // 41-49, 50 là ruby
        1710000,
        1881000,
        2052000,
        2223000,
        0, // 51-54, 55 là ruby
        2394000,
        2565000,
        2736000,
        2907000,
        0, // 56-59, 60 là ruby
        3420000,
        3762000,
        4104000,
        4446000,
        0, // 61-64, 65 là ruby
        5130000,
        5472000,
        5814000,
        6156000,
        0, // 66-69, 70 là ruby
        6498000,
        7147000,
        7797600,
        8447400,
        0, // 71-74, 75 là ruby
        9747000,
        10396800,
        11046600,
        11696400,
        0, // 76-79, 80 là ruby
        12346200,
        13580820,
        14815440,
        16050060,
        0, // 81-84, 85 là ruby
        18519300,
        19753920,
        20988540,
        22223160,
        0, // 86-89, 90 là ruby
        23457780,
        26976448,
        30495114,
        34013782,
        0, // 91-94, 95 là ruby
        41051116,
        44569782,
        48008450,
        0, // 96-98, 99 là ruby
      ];

      // Coin per tap by level
      const TAP_COIN_BY_LEVEL = [
        { from: 1, to: 10, value: 24 },
        { from: 11, to: 20, value: 27 },
        { from: 21, to: 30, value: 31 },
        { from: 31, to: 40, value: 35 },
        { from: 41, to: 49, value: 39 },
        { from: 50, to: 60, value: 47 },
        { from: 61, to: 70, value: 54 },
        { from: 71, to: 80, value: 61 },
        { from: 81, to: 90, value: 70 },
        { from: 91, to: 100, value: 80 },
      ];

      // =====================
      // 2. Game State Management
      // =====================

      function getLevelHP(level) {
        if (level <= 1) return 100;
        let hp = 100;
        for (let lv = 2; lv <= level; lv++) {
          if (lv <= 30) hp += 50;
          else if (lv <= 60) hp += 100;
          else if (lv <= 90) hp += 150;
          else hp += 200;
        }
        return hp;
      }

      function getTapCoin(level) {
        if (level <= 1) return 24;
        for (const range of TAP_COIN_BY_LEVEL) {
          if (level >= range.from && level <= range.to) return range.value;
        }
        return 24;
      }

      function getUpgradeMultiplier(level) {
        if (level <= 1) return 1;
        return 1 + (level - 1) * 0.05;
      }

      function getLevelUpRequirement(level) {
        return LEVEL_UP_REQUIREMENTS[level - 1] || 0;
      }

      function getTotalCoinsForLevel(level) {
        if (level <= 1) return 0;
        let total = 0;
        for (let i = 0; i < level - 1; i++) {
          total += LEVEL_UP_REQUIREMENTS[i] || 0;
        }
        return total;
      }

      function canLevelUp(currentLevel, totalCoins) {
        const currentLevelRequirement = getLevelUpRequirement(currentLevel);
        return (
          currentLevelRequirement > 0 &&
          totalCoins >= currentLevelRequirement &&
          currentLevel < 100
        );
      }

      function loadGameState() {
        const data = localStorage.getItem("game_interface_state");
        if (data) return JSON.parse(data);
        return {
          level: 1,
          hp: getLevelHP(1),
          coinEarn: 0,
          coinCount: 0,
          lastRecover: Date.now(),
          lastZeroHP: null,
        };
      }

      function saveGameState(state) {
        localStorage.setItem("game_interface_state", JSON.stringify(state));

        // Auto-sync to server when game state changes
        if (telegramUserId) {
          syncGameStateToServer(state);
        }
      }

      // Enhanced load function that tries server first, then localStorage
      async function loadGameStateEnhanced() {
        // Try to load from server first
        const serverState = await loadGameStateFromServer();
        if (serverState) {
          // Save to localStorage for offline access
          localStorage.setItem(
            "game_interface_state",
            JSON.stringify(serverState)
          );
          return serverState;
        }

        // Fallback to localStorage
        return loadGameState();
      }

      // =====================
      // 3. UI Update Functions
      // =====================

      function updateUI(state) {
        const maxHP = getLevelHP(state.level);
        const hpPercentage = Math.max(
          0,
          Math.min(100, (state.hp / maxHP) * 100)
        );

        // Update HP display
        document.getElementById(
          "hp-display"
        ).textContent = `${state.hp}/${maxHP}`;
        document.getElementById("hp-bar").style.width = `${hpPercentage}%`;

        // Update HP progress icon position
        const hpProgressIcon = document.querySelector(
          ".hp-progress-container .progress-icon"
        );
        if (hpProgressIcon) {
          hpProgressIcon.style.left = `${hpPercentage}%`;
        }

        // Update coin displays
        // Ruby (coin-count) stays at 0 - not used
        // Money (coin-earn) shows final coinCount after HP=0
        // Total-coins box shows current coinEarn during tapping
        document.getElementById("coin-count").textContent = "0";
        document.getElementById("coin-earn").textContent = state.coinCount;
        document.getElementById("total-coins").textContent = state.coinEarn;

        // Update level displays
        document.getElementById(
          "hp-level-display"
        ).textContent = `${state.level}/100`;
        document.getElementById(
          "lp-level-display"
        ).textContent = `${state.level}/100`;

        // Calculate level progress based on current coins vs level up requirement
        const currentLevelRequirement = getLevelUpRequirement(state.level);
        let levelProgress = 0;

        if (currentLevelRequirement > 0) {
          // Calculate progress based on current coins vs requirement for current level
          const totalCoinsForCurrentLevel = getTotalCoinsForLevel(state.level);
          const totalCoinsAvailable = state.coinCount + state.coinEarn;
          const coinsTowardsCurrentLevel =
            totalCoinsAvailable - totalCoinsForCurrentLevel;

          levelProgress = Math.min(
            100,
            Math.max(
              0,
              (coinsTowardsCurrentLevel / currentLevelRequirement) * 100
            )
          );
        } else {
          // If no requirement (max level or special level), show 100%
          levelProgress = 100;
        }

        // Update level progress bars - fix the IDs
        const hpLevelBar = document.getElementById("hp-level-bar");
        const lpLevelBar = document.getElementById("lp-level-bar");

        if (hpLevelBar) {
          hpLevelBar.style.width = `${levelProgress}%`;
        }
        if (lpLevelBar) {
          lpLevelBar.style.width = `${levelProgress}%`;
        }

        // Update level progress icons
        const hpLevelIcon = document.querySelector(
          ".hp-level-progress-container .level-progress-icon"
        );
        const lpLevelIcon = document.querySelector(
          ".lp-level-progress-container .level-progress-icon"
        );

        if (hpLevelIcon) {
          hpLevelIcon.style.left = `${levelProgress}%`;
        }
        if (lpLevelIcon) {
          lpLevelIcon.style.left = `${levelProgress}%`;
        }
      }

      // =====================
      // 4. Flying Coin Animation
      // =====================

      // Track which target to use for alternating coin flights
      let coinTargetToggle = true; // true = HP, false = MT

      function updateCoinTargetIndicator() {
        // Remove indicator from both containers
        const hpContainer = document.querySelector(
          ".hp-level-progress-container"
        );
        const mtContainer = document.querySelector(
          ".lp-level-progress-container"
        );

        if (hpContainer) hpContainer.classList.remove("coin-target-indicator");
        if (mtContainer) mtContainer.classList.remove("coin-target-indicator");

        // Add indicator to the next target
        const nextTarget = coinTargetToggle ? hpContainer : mtContainer;
        if (nextTarget) {
          nextTarget.classList.add("coin-target-indicator");
        }

        console.log(
          `🎯 Next coins will target: ${
            coinTargetToggle ? "HP" : "MT"
          } progress bar`
        );
      }

      function createFlyingCoin(startX, startY, targetElement) {
        const coin = document.createElement("div");
        coin.className = "flying-coin";
        coin.style.left = startX + "px";
        coin.style.top = startY + "px";

        const targetRect = targetElement.getBoundingClientRect();
        const targetX = targetRect.left + targetRect.width / 2;
        const targetY = targetRect.top + targetRect.height / 2;

        const deltaX = targetX - startX;
        const deltaY = targetY - startY;

        coin.style.setProperty("--tx", deltaX + "px");
        coin.style.setProperty("--ty", deltaY + "px");

        document.body.appendChild(coin);

        setTimeout(() => {
          if (coin.parentNode) {
            coin.parentNode.removeChild(coin);
          }
        }, 2500);
      }

      // =====================
      // 5. Character Animation Functions
      // =====================

      function createSparkles() {
        const sparkleContainer = document.createElement("div");
        sparkleContainer.style.cssText = `
          position: absolute;
          bottom: -50px;
          left: 50%;
          transform: translateX(-50%);
          width: 600px;
          height: 600px;
          pointer-events: none;
          z-index: 6;
        `;

        // Create multiple sparkle particles
        for (let i = 0; i < 12; i++) {
          const sparkle = document.createElement("div");
          const size = Math.random() * 8 + 4;
          const delay = Math.random() * 0.3;
          const duration = Math.random() * 0.8 + 0.6;
          const x = (Math.random() - 0.5) * 400;
          const y = (Math.random() - 0.5) * 400;

          sparkle.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            background: radial-gradient(circle, #ffffff 0%, #ffeb3b 50%, transparent 100%);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: sparkleFloat ${duration}s ease-out ${delay}s forwards;
            opacity: 0;
          `;

          sparkle.style.setProperty("--x", x + "px");
          sparkle.style.setProperty("--y", y + "px");

          sparkleContainer.appendChild(sparkle);
        }

        // Add sparkle animation
        const style = document.createElement("style");
        style.textContent = `
          @keyframes sparkleFloat {
            0% {
              transform: translate(-50%, -50%) scale(0) rotate(0deg);
              opacity: 0;
            }
            20% {
              transform: translate(calc(-50% + var(--x) * 0.2), calc(-50% + var(--y) * 0.2)) scale(1) rotate(90deg);
              opacity: 1;
            }
            80% {
              transform: translate(calc(-50% + var(--x) * 0.8), calc(-50% + var(--y) * 0.8)) scale(0.8) rotate(270deg);
              opacity: 0.8;
            }
            100% {
              transform: translate(calc(-50% + var(--x)), calc(-50% + var(--y))) scale(0) rotate(360deg);
              opacity: 0;
            }
          }
        `;
        document.head.appendChild(style);

        return { container: sparkleContainer, style };
      }

      function triggerCharacterPress(isSpecial = false) {
        const characterContainer = document.querySelector(
          ".character-container"
        );
        const soleElement = document.getElementById("sole");
        const lightEffect = document.getElementById("light-effect");

        characterContainer.classList.add("pressed");
        soleElement.classList.add("pressed");

        // Show light effect (without pressed movement)
        if (lightEffect) {
          lightEffect.classList.add("show");
          if (isSpecial) {
            lightEffect.classList.add("special");
          }
        }

        // Create sparkles effect
        const sparkleData = createSparkles();
        const soleContainer = soleElement.parentElement;
        soleContainer.appendChild(sparkleData.container);

        setTimeout(
          () => {
            characterContainer.classList.remove("pressed");
            soleElement.classList.remove("pressed");

            // Hide light effect
            if (lightEffect) {
              lightEffect.classList.remove("show");
              if (isSpecial) {
                lightEffect.classList.remove("special");
              }
            }

            // Clean up sparkles
            setTimeout(() => {
              if (sparkleData.container.parentNode) {
                sparkleData.container.parentNode.removeChild(
                  sparkleData.container
                );
              }
              if (sparkleData.style.parentNode) {
                sparkleData.style.parentNode.removeChild(sparkleData.style);
              }
            }, 1000);
          },
          isSpecial ? 300 : 200
        );
      }

      // =====================
      // 6. Main Tap Function
      // =====================

      function tap(event, multiplier = 1) {
        // Generate unique ID for this tap call
        const tapId = Date.now() + Math.random().toString(36).substr(2, 9);
        console.log("🎯 TAP FUNCTION CALLED - ID:", tapId);
        console.log("Tap function called!", event, multiplier);
        let state = loadGameState();
        console.log("Current state:", state);

        if (state.hp <= 0) {
          console.log("Cannot tap - HP is 0");
          return;
        }

        // Check for 3-finger tap on touch devices - IMPROVED DETECTION
        let finalMultiplier = multiplier;
        let hpMultiplier = 1; // Separate multiplier for HP loss
        let is3FingerTap = false;

        // Enhanced 3-finger detection with multiple checks
        if (event && event.touches) {
          const touchCount = event.touches.length;
          console.log("Touch count detected:", touchCount);

          if (touchCount >= 3) {
            // Don't modify finalMultiplier here - handle it in coin calculation
            hpMultiplier = 3; // 3x HP loss for 3-finger tap (12 HP)
            is3FingerTap = true;
            console.log(
              "🔥 3-FINGER TAP CONFIRMED! Touch count:",
              touchCount,
              "HP multiplier:",
              hpMultiplier
            );

            // Add special visual feedback for 3-finger tap
            triggerSpecial3FingerEffect();
          } else {
            console.log("Normal tap detected with", touchCount, "finger(s)");
          }
        } else if (event && !event.touches) {
          console.log("Mouse click detected (no touch data)");
        } else {
          console.log("No event data available");
        }

        // PROTECTION: Check if this is a duplicate HP change - ENHANCED
        const currentTime = Date.now();
        const oldHP = state.hp; // Move this line here - BEFORE it's used

        // For 3-finger taps, use stricter duplicate detection
        if (is3FingerTap) {
          // Check multiple conditions for duplicate detection
          const timeSinceLastHPChange = currentTime - lastHPChangeTime;
          const isSameHP = lastHPValue === oldHP;
          const tooSoon = timeSinceLastHPChange < 1500; // Increased from 1000ms to 1500ms

          console.log("🛡️ 3-FINGER TAP DUPLICATE CHECK:");
          console.log("Time since last HP change:", timeSinceLastHPChange);
          console.log(
            "Is same HP value:",
            isSameHP,
            "(",
            lastHPValue,
            "vs",
            oldHP,
            ")"
          );
          console.log("Too soon?", tooSoon);

          if (tooSoon && isSameHP) {
            console.log("🛡️ DUPLICATE 3-FINGER TAP DETECTED - BLOCKING");
            return; // Exit early to prevent duplicate processing
          }
        }

        // Update tracking variables BEFORE processing
        lastHPChangeTime = currentTime;
        lastHPValue = oldHP;

        console.log("✅ TAP PROCESSING APPROVED - ID:", tapId);

        // Create flying coin effect - alternating between HP and MT level progress bars
        if (event) {
          // Get the HP level and MT level progress containers
          const hpLevelContainer = document.querySelector(
            ".hp-level-progress-container"
          );
          const mtLevelContainer = document.querySelector(
            ".lp-level-progress-container"
          );

          if (hpLevelContainer && mtLevelContainer) {
            // Determine target based on toggle state
            const targetContainer = coinTargetToggle
              ? hpLevelContainer
              : mtLevelContainer;
            const targetName = coinTargetToggle ? "HP" : "MT";

            // Toggle for next tap
            coinTargetToggle = !coinTargetToggle;

            // Update visual indicator for next tap
            updateCoinTargetIndicator();

            console.log(
              `🎯 Flying coins targeting: ${targetName} progress bar`
            );

            // Number of coins based on tap type
            const baseCoins = is3FingerTap ? 3 : 1;

            // Create coins flying to the selected target
            for (let i = 0; i < baseCoins; i++) {
              setTimeout(() => {
                createFlyingCoin(
                  event.clientX ||
                    event.touches?.[0]?.clientX ||
                    window.innerWidth / 2,
                  event.clientY ||
                    event.touches?.[0]?.clientY ||
                    window.innerHeight / 2,
                  targetContainer
                );
              }, i * 100); // Stagger coins with 100ms delay
            }
          }

          // Trigger character press animation
          if (!is3FingerTap) {
            triggerCharacterPress();
          }
        }

        // Decrease HP with proper calculation
        const baseHPLoss = 4; // Base HP loss per tap
        const hpLoss = Math.round(baseHPLoss * hpMultiplier); // Should be 4 for normal, 12 for 3-finger

        // Validate HP loss calculation
        const expectedHPLoss = is3FingerTap ? 12 : 4; // Back to 12 HP loss

        // FORCE CORRECT HP LOSS - especially for 3-finger taps
        let actualHPLoss;
        if (is3FingerTap) {
          // Force exactly 12 HP loss for 3-finger tap
          actualHPLoss = 12;
          console.log("🔒 FORCING 3-finger tap HP loss to exactly 12");
        } else {
          // Use calculated value for normal taps
          actualHPLoss = hpLoss;
        }

        if (hpLoss !== expectedHPLoss) {
          console.error(
            "HP loss calculation error! Expected:",
            expectedHPLoss,
            "Got:",
            hpLoss,
            "Using forced value:",
            actualHPLoss
          );
        }

        // Apply the HP loss
        state.hp -= actualHPLoss;
        console.log(
          "HP changed from",
          oldHP,
          "to",
          state.hp,
          "(-" + actualHPLoss + " HP)",
          is3FingerTap ? "(3-finger tap - FORCED)" : "(normal tap)"
        );

        // Calculate coins with proper multiplier - FIXED CALCULATION
        let tapCoin;
        const baseCoin =
          getTapCoin(state.level) * getUpgradeMultiplier(state.level);

        console.log("=== COIN CALCULATION DEBUG ===");
        console.log("Level:", state.level);
        console.log("getTapCoin(level):", getTapCoin(state.level));
        console.log(
          "getUpgradeMultiplier(level):",
          getUpgradeMultiplier(state.level)
        );
        console.log("baseCoin:", baseCoin);
        console.log("is3FingerTap:", is3FingerTap);
        console.log("finalMultiplier:", finalMultiplier);

        if (finalMultiplier === 0.25) {
          // Auto-earn case
          tapCoin = Math.floor(baseCoin / 4);
          console.log("Auto-earn calculation:", baseCoin, "/ 4 =", tapCoin);
        } else if (is3FingerTap) {
          // 3-finger tap: exactly 3x the base coin - FIXED CALCULATION
          tapCoin = Math.floor(baseCoin * 3);
          console.log(
            "3-finger tap coin calculation:",
            baseCoin,
            "* 3 =",
            tapCoin
          );
        } else {
          // Normal tap: base coin * finalMultiplier
          tapCoin = Math.floor(baseCoin * finalMultiplier);
          console.log(
            "Normal tap coin calculation:",
            baseCoin,
            "*",
            finalMultiplier,
            "=",
            tapCoin
          );
        }

        console.log("Final tapCoin value:", tapCoin);
        console.log("=== END COIN CALCULATION ===");

        // Add coins to coinEarn (which shows in total-coins box during tapping)
        state.coinEarn += tapCoin;
        console.log("=== TAP SUMMARY ===");
        console.log("Tap type:", is3FingerTap ? "3-FINGER TAP" : "NORMAL TAP");
        console.log("Base coin per tap:", getTapCoin(state.level));
        console.log("Upgrade multiplier:", getUpgradeMultiplier(state.level));
        console.log("Final coin earned:", tapCoin);
        console.log("HP lost:", actualHPLoss);
        console.log("Total coinEarn:", state.coinEarn);
        console.log("==================");

        // Handle HP reaching 0
        if (state.hp <= 0) {
          state.hp = 0;
          // Transfer coins from coinEarn to coinCount (top display)
          state.coinCount += state.coinEarn;
          state.coinEarn = 0;
          state.lastRecover = Date.now();
          state.lastZeroHP = Date.now();

          saveGameState(state);
          updateUI(state);

          // Check for level up after delay
          setTimeout(() => {
            let currentState = loadGameState();
            if (canLevelUp(currentState.level, currentState.coinCount)) {
              currentState.level++;
              if (currentState.hp > 0) {
                currentState.hp = getLevelHP(currentState.level);
              }
              saveGameState(currentState);
              updateUI(currentState);
              showLevelUpPopup(currentState.level);
            }
          }, 500);

          return;
        }

        // Check for level up (when HP > 0)
        if (canLevelUp(state.level, state.coinCount)) {
          const oldLevel = state.level;
          state.level++;
          if (state.hp > 0) {
            state.hp = getLevelHP(state.level);
          }
          showLevelUpPopup(state.level);
        }

        saveGameState(state);
        updateUI(state);
        console.log("Tap completed, state saved - ID:", tapId);
      }

      // =====================
      // 6.1. Special 3-Finger Effect
      // =====================

      function triggerSpecial3FingerEffect() {
        // Add special glow effect to character
        const character = document.getElementById("younghee");
        const sole = document.getElementById("sole");

        if (character && sole) {
          character.style.filter =
            "drop-shadow(0 0 20px #FFD700) brightness(1.3)";
          sole.style.filter = "drop-shadow(0 0 15px #FFD700) brightness(1.2)";

          // Remove effect after animation
          setTimeout(() => {
            character.style.filter = "";
            sole.style.filter = "";
          }, 500);
        }

        // Show 3x multiplier text
        show3xMultiplierText();

        // Trigger special character press with light effect
        triggerCharacterPress(true);
      }

      function show3xMultiplierText() {
        // Create floating 3x text
        const multiplierText = document.createElement("div");
        multiplierText.textContent = "🔥 3X COINS! 🔥";
        multiplierText.style.cssText = `
          position: fixed;
          top: 30%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 28px;
          font-weight: bold;
          color: #FFD700;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px #FFD700;
          z-index: 9999;
          pointer-events: none;
          animation: bounce3x 1.5s ease-out forwards;
          font-family: 'Gugi', sans-serif;
          border: 2px solid #FFD700;
          background: rgba(0,0,0,0.8);
          padding: 10px 20px;
          border-radius: 15px;
        `;

        // Add bounce animation
        const style = document.createElement("style");
        style.textContent = `
          @keyframes bounce3x {
            0% { 
              transform: translate(-50%, -50%) scale(0.3) rotate(-10deg); 
              opacity: 0; 
            }
            30% { 
              transform: translate(-50%, -50%) scale(1.4) rotate(5deg); 
              opacity: 1; 
            }
            60% { 
              transform: translate(-50%, -50%) scale(0.9) rotate(-2deg); 
              opacity: 1; 
            }
            80% { 
              transform: translate(-50%, -50%) scale(1.1) rotate(1deg); 
              opacity: 1; 
            }
            100% { 
              transform: translate(-50%, -50%) scale(1) translateY(-50px) rotate(0deg); 
              opacity: 0; 
            }
          }
        `;
        document.head.appendChild(style);
        document.body.appendChild(multiplierText);

        // Add screen flash effect
        const flashOverlay = document.createElement("div");
        flashOverlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
          z-index: 9998;
          pointer-events: none;
          animation: flashEffect 0.5s ease-out forwards;
        `;

        const flashStyle = document.createElement("style");
        flashStyle.textContent = `
          @keyframes flashEffect {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
          }
        `;
        document.head.appendChild(flashStyle);
        document.body.appendChild(flashOverlay);

        // Remove after animation
        setTimeout(() => {
          if (multiplierText.parentNode) {
            multiplierText.parentNode.removeChild(multiplierText);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
          if (flashOverlay.parentNode) {
            flashOverlay.parentNode.removeChild(flashOverlay);
          }
          if (flashStyle.parentNode) {
            flashStyle.parentNode.removeChild(flashStyle);
          }
        }, 1500);
      }

      // =====================
      // 7. HP Recovery Function
      // =====================

      async function recoverHP() {
        let state = loadGameState();

        // Only 3-minute 2% HP recovery logic
        const currentTime = Date.now();
        if (!state.lastRecover) {
          state.lastRecover = currentTime;
        }

        const timeSinceLastRecover = currentTime - state.lastRecover;
        if (timeSinceLastRecover >= 3 * 60 * 1000) {
          // 3 minutes
          const maxHP = getLevelHP(state.level);
          const recoveryAmount = Math.floor(maxHP * 0.02); // 2% of max HP

          // Recover 2% regardless of current HP amount, but don't exceed max HP
          if (state.hp < maxHP) {
            const oldHP = state.hp;
            state.hp = Math.min(maxHP, state.hp + recoveryAmount);
            state.lastRecover = currentTime;

            // Save locally first
            saveGameState(state);
            updateUI(state);

            // Sync HP recovery with server
            try {
              const response = await fetch(`/api/user/${telegramUserId}`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  hp: state.hp,
                  lastRecover: state.lastRecover,
                }),
              });

              if (response.ok) {
                const result = await response.json();
                console.log(
                  `💚 HP Recovery synced: ${oldHP} → ${state.hp} (+${recoveryAmount})`
                );

                // Show recovery notification
                showFloatingText(`+${recoveryAmount} HP`, "#4CAF50");
              } else {
                console.warn("⚠️ Failed to sync HP recovery with server");
              }
            } catch (error) {
              console.warn("⚠️ Error syncing HP recovery:", error);
            }
          }
        }
      }

      // =====================
      // 8. Level Up Popup Functions
      // =====================

      function showLevelUpPopup(newLevel) {
        const popup = document.getElementById("level-up-popup");
        const titleElement = popup.querySelector(".level-up-title");

        if (titleElement) {
          titleElement.textContent = `Level ${newLevel}!`;
        }

        popup.style.display = "flex";
        popup.classList.add("show");
      }

      function closeLevelUpPopup() {
        const popup = document.getElementById("level-up-popup");
        popup.classList.remove("show");
        setTimeout(() => {
          popup.style.display = "none";
        }, 300);
      }

      // =====================
      // 9. Auto Earn Function
      // =====================

      let isAutoEarnEnabled = false;
      let autoEarnInterval = null;

      function toggleAutoEarn() {
        const button = document.getElementById("auto-earn-button");

        if (isAutoEarnEnabled) {
          // Disable auto earn
          isAutoEarnEnabled = false;
          if (autoEarnInterval) {
            clearInterval(autoEarnInterval);
            autoEarnInterval = null;
          }
          button.classList.remove("active");
        } else {
          // Enable auto earn
          isAutoEarnEnabled = true;
          autoEarnInterval = setInterval(() => {
            if (isAutoEarnEnabled) {
              const fakeEvent = {
                clientX: window.innerWidth / 2,
                clientY: window.innerHeight / 2,
              };
              tap(fakeEvent, 0.25);
            }
          }, 1000);
          button.classList.add("active");
        }
      }

      // =====================
      // 10. Event Listeners
      // =====================

      // Add debounce mechanism to prevent multiple taps
      let lastTapTime = 0;
      const TAP_DEBOUNCE_MS = 50; // Reduced from 100ms to 50ms for better responsiveness

      // Separate tracking for multi-touch to avoid debounce interference
      let lastMultiTouchTime = 0;
      const MULTI_TOUCH_DEBOUNCE_MS = 600; // Increased from 500ms to 800ms to prevent duplicates

      // Add flag to track if 3-finger tap is being processed
      let isProcessing3FingerTap = false;

      // Track last HP change to prevent duplicates - ENHANCED
      let lastHPChangeTime = 0;
      let lastHPValue = 0;
      let lastTapProcessTime = 0; // New: track when tap was last processed

      function debouncedTap(event, multiplier = 1) {
        const currentTime = Date.now();

        // ENHANCED DUPLICATE PROTECTION
        if (currentTime - lastTapProcessTime < 100) {
          console.log("❌ TAP IGNORED - Too soon after last tap processing");
          return;
        }

        // Check if this is a multi-touch event (3+ fingers)
        const isMultiTouch =
          event && event.touches && event.touches.length >= 3;

        console.log("=== DEBOUNCED TAP CALLED ===");
        console.log("Current time:", currentTime);
        console.log("Is multi-touch:", isMultiTouch);
        console.log("Touch count:", event?.touches?.length || "N/A");

        if (isMultiTouch) {
          // Use separate debounce for multi-touch
          console.log("Last multi-touch time:", lastMultiTouchTime);
          console.log(
            "Time since last multi-touch:",
            currentTime - lastMultiTouchTime
          );
          console.log("Is processing 3-finger tap:", isProcessing3FingerTap);

          if (isProcessing3FingerTap) {
            console.log(
              "❌ Multi-touch tap IGNORED - already processing 3-finger tap"
            );
            return;
          }

          if (currentTime - lastMultiTouchTime < MULTI_TOUCH_DEBOUNCE_MS) {
            console.log("❌ Multi-touch tap IGNORED due to debounce");
            return;
          }

          // Set processing flag IMMEDIATELY
          isProcessing3FingerTap = true;
          lastMultiTouchTime = currentTime;
          lastTapProcessTime = currentTime; // Update tap process time
          console.log(
            "✅ Multi-touch tap ACCEPTED, updating lastMultiTouchTime to:",
            lastMultiTouchTime
          );
          console.log(
            "Multi-touch detected with",
            event.touches.length,
            "fingers"
          );

          // Clear processing flag after a longer delay
          setTimeout(() => {
            isProcessing3FingerTap = false;
            console.log("🔄 3-finger tap processing flag cleared");
          }, 600); // Increased from 300ms to 600ms
        } else {
          // Use normal debounce for single touch
          console.log("Last single tap time:", lastTapTime);
          console.log("Time since last single tap:", currentTime - lastTapTime);

          if (currentTime - lastTapTime < TAP_DEBOUNCE_MS) {
            console.log("❌ Single tap IGNORED due to debounce");
            return;
          }
          lastTapTime = currentTime;
          lastTapProcessTime = currentTime; // Update tap process time
          console.log(
            "✅ Single tap ACCEPTED, updating lastTapTime to:",
            lastTapTime
          );
        }

        console.log("🎯 Calling tap function...");
        tap(event, multiplier);
      }

      document.addEventListener("DOMContentLoaded", function () {
        // Initialize Telegram integration
        getTelegramUserId();

        // Initialize game with enhanced loading (server + localStorage)
        loadGameStateEnhanced().then((initialState) => {
          updateUI(initialState);

          // Initialize coin target indicator
          updateCoinTargetIndicator();

          // Initialize bottom navigation
          initializeBottomNavigation();

          console.log(
            "🎮 Game Interface Initialized with state:",
            initialState
          );
          console.log("📱 Telegram User ID:", telegramUserId);
        });


        // Add tap event listeners for the main container only
        const mainContainer = document.querySelector(".w-\\[375px\\]");
        if (mainContainer) {
          // Handle click events (for desktop/mouse)
          mainContainer.addEventListener("click", function (event) {
            // Don't tap if clicking on buttons or UI elements
            if (
              event.target.closest("#auto-earn-button") ||
              event.target.closest(".level-up-popup") ||
              event.target.closest("button")
            ) {
              return;
            }

            // Check if click is in bottom navigation area or below
            const bottomNavElement = document.getElementById('bottom-navigation');
            if (bottomNavElement) {
              const bottomNavRect = bottomNavElement.getBoundingClientRect();
              const clickY = event.clientY;
              
              // If click is at or below the bottom navigation, don't tap
              if (clickY >= bottomNavRect.top) {
                console.log("❌ Click blocked - in bottom navigation area");
                return;
              }
            }

            event.preventDefault();
            event.stopPropagation();
            debouncedTap(event);
          });

          // Handle touch events (for mobile) - IMPROVED FOR MULTI-TOUCH
          mainContainer.addEventListener("touchstart", function (event) {
            // Don't tap if touching buttons or UI elements
            if (
              event.target.closest("#auto-earn-button") ||
              event.target.closest(".level-up-popup") ||
              event.target.closest("button")
            ) {
              return;
            }

            // Check if touch is in bottom navigation area or below
            const bottomNavElement = document.getElementById('bottom-navigation');
            if (bottomNavElement && event.touches && event.touches.length > 0) {
              const bottomNavRect = bottomNavElement.getBoundingClientRect();
              const touchY = event.touches[0].clientY;
              
              // If touch is at or below the bottom navigation, don't tap
              if (touchY >= bottomNavRect.top) {
                console.log("❌ Touch blocked - in bottom navigation area");
                return;
              }
            }

            // Log touch information for debugging
            console.log("Touch detected:", event.touches.length, "fingers");

            // For multi-touch, don't prevent default immediately to allow proper detection
            if (event.touches.length >= 3) {
              console.log("3+ finger touch detected, processing...");
              // Allow some time for touch registration before preventing default
              setTimeout(() => {
                event.preventDefault();
              }, 10);
            } else {
              event.preventDefault();
            }

            event.stopPropagation();
            debouncedTap(event);
          });

          // Add touchend handler to catch any missed multi-touch events
          mainContainer.addEventListener("touchend", function (event) {
            // Check if we had multiple touches that just ended
            if (event.changedTouches && event.changedTouches.length >= 2) {
              console.log(
                "Multi-touch ended, checking for missed 3-finger tap"
              );
              // This might catch cases where touchstart missed the multi-touch
            }
            event.preventDefault();
          });

          // Reduce interference from touchmove
          mainContainer.addEventListener("touchmove", function (event) {
            // Only prevent default for single touch to avoid interfering with multi-touch detection
            if (event.touches.length === 1) {
              event.preventDefault();
            }
          });
        }

        // Auto earn button
        document
          .getElementById("auto-earn-button")
          .addEventListener("click", function (event) {
            event.preventDefault();
            event.stopPropagation();
            toggleAutoEarn();
          });

        // Auto earn button touch support
        document
          .getElementById("auto-earn-button")
          .addEventListener("touchstart", function (event) {
            event.preventDefault();
            event.stopPropagation();
            toggleAutoEarn();
          });

        // Prevent auto earn button from being affected by main container events
        document
          .getElementById("auto-earn-button")
          .addEventListener("touchend", function (event) {
            event.preventDefault();
            event.stopPropagation();
          });

        document
          .getElementById("auto-earn-button")
          .addEventListener("touchmove", function (event) {
            event.preventDefault();
            event.stopPropagation();
          });

        // HP recovery interval
        setInterval(recoverHP, 60 * 1000); // Every minute

        console.log("Game Interface Initialized");
      });

      // Close popup when clicking outside
      document
        .getElementById("level-up-popup")
        .addEventListener("click", function (event) {
          if (event.target === this) {
            closeLevelUpPopup();
          }
        });

      // =====================
      // 6. Visual Effects Functions
      // =====================

      function showFloatingText(text, color = "#FFD93D", x = null, y = null) {
        const floatingText = document.createElement("div");
        floatingText.textContent = text;
        floatingText.style.cssText = `
          position: fixed;
          left: ${x || window.innerWidth / 2 - 50}px;
          top: ${y || window.innerHeight / 2 - 100}px;
          color: ${color};
          font-size: 24px;
          font-weight: bold;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
          pointer-events: none;
          z-index: 10001;
          animation: floatUp 2s ease-out forwards;
        `;

        // Add floating animation
        const style = document.createElement("style");
        style.textContent = `
          @keyframes floatUp {
            0% { 
              opacity: 1; 
              transform: translateY(0px) scale(1); 
            }
            50% { 
              opacity: 1; 
              transform: translateY(-30px) scale(1.1); 
            }
            100% { 
              opacity: 0; 
              transform: translateY(-60px) scale(0.8); 
            }
          }
        `;
        document.head.appendChild(style);
        document.body.appendChild(floatingText);

        // Remove after animation
        setTimeout(() => {
          if (floatingText.parentNode) {
            floatingText.parentNode.removeChild(floatingText);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
        }, 2000);
      }

      function showMultiplierEffect(multiplier) {
        // Implement multiplier effect logic
        console.log(`Multiplier effect: ${multiplier}x`);
      }

      // Sync game state with server
      async function syncGameState() {
        try {
          const state = loadGameState();

          // First, get latest data from server
          const getResponse = await fetch(`/api/user/${telegramUserId}`);
          if (getResponse.ok) {
            const serverData = await getResponse.json();
            if (serverData.success && serverData.data) {
              // Update local state with server data if server has newer lastRecover
              if (
                serverData.data.lastRecover &&
                serverData.data.lastRecover > (state.lastRecover || 0)
              ) {
                state.lastRecover = serverData.data.lastRecover;
                console.log(
                  "🔄 Updated lastRecover from server:",
                  new Date(state.lastRecover)
                );
              }
            }
          }

          // Then sync current state to server
          const response = await fetch(`/api/sync/${telegramUserId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              level: state.level,
              hp: state.hp,
              coinCount: state.coinCount,
              coinEarn: state.coinEarn,
              lastRecover: state.lastRecover || Date.now(),
              lastZeroHP: state.lastZeroHP,
            }),
          });

          if (response.ok) {
            const result = await response.json();
            console.log("✅ Game state synced successfully");

            // Update local state with any server corrections
            if (result.data) {
              if (result.data.ruby !== undefined)
                state.coinCount = result.data.ruby;
              if (result.data.coins !== undefined)
                state.coinEarn = result.data.coins;
              if (result.data.level !== undefined)
                state.level = result.data.level;
              if (result.data.hp !== undefined) state.hp = result.data.hp;

              saveGameState(state);
              updateUI(state);
            }
          } else {
            console.warn("⚠️ Failed to sync game state");
          }
        } catch (error) {
          console.warn("⚠️ Error syncing game state:", error);
        }
      }

      // =====================
      // 11. Bottom Navigation Functions
      // =====================

      function setActiveNavItem(activeId) {
        // Remove active class from all nav items
        const navItems = document.querySelectorAll('.nav-item');
        navItems.forEach(item => {
          item.classList.remove('active');
        });

        // Add active class to the specified item
        const activeItem = document.getElementById(activeId);
        if (activeItem) {
          activeItem.classList.add('active');
          console.log(`🎯 Navigation active: ${activeId}`);
        }
      }

      function initializeBottomNavigation() {
        // Set earn as active by default
        setActiveNavItem('nav-earn');

        // Add click handlers for navigation items
        const navItems = document.querySelectorAll('.nav-item');
        navItems.forEach(item => {
          item.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Handle navigation based on item
            switch(item.id) {
              case 'nav-earn':
                console.log('📈 Earn tab selected');
                // Already on earn page, no action needed
                setActiveNavItem('nav-earn');
                break;
              case 'nav-exchange':
                console.log('🔄 Exchange tab selected - redirecting...');
                window.location.href = 'exchange.html';
                break;
              case 'nav-boost':
                console.log('🚀 Boost tab selected');
                window.location.href = 'boost.html';
                break;
              case 'nav-point':
                console.log('🎯 Point tab selected');
                window.location.href = 'point.html';
                break;
            }
          });
        });
      }

      // =====================
      // 10. Event Listeners
      // =====================
    </script>
  </body>
</html>
