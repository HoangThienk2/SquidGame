<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Squid Game - Yeonghee</title>

    <!-- Favicon -->
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü¶ë</text></svg>"
    />

    <!-- Meta Tags -->
    <meta
      name="description"
      content="Play the exciting Squid Game clicking game! Click to earn coins and level up in this thrilling game experience."
    />
    <meta
      name="keywords"
      content="squid game, clicking game, online game, coins, level up"
    />
    <meta name="author" content="Squid Game" />

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content=" Squid Game - Yeonghee Game" />
    <meta
      property="og:description"
      content="Play as Yeonghee in the ultimate Squid Game challenge! Tap to survive and collect coins."
    />
    <meta
      property="og:image"
      content="https://squid-game-m29i-123.vercel.app/images/thumbnail.png"
    />
    <meta property="og:image:width" content="475" />
    <meta property="og:image:height" content="220" />
    <meta property="og:url" content="https://squid-game-m29i-123.vercel.app/" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Squid Game" />

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content=" Squid Game - Yeonghee Game" />
    <meta
      name="twitter:description"
      content="Play as Yeonghee in the ultimate Squid Game challenge!"
    />
    <meta
      name="twitter:image"
      content="https://squid-game-m29i-123.vercel.app/images/thumbnail.png"
    />

    <!-- Telegram Mini App Meta Tags -->
    <meta
      name="telegram:image"
      content="https://squid-game-m29i-123.vercel.app/images/thumbnail.png"
    />
    <meta name="telegram:title" content=" Squid Game - Yeonghee" />
    <meta
      name="telegram:description"
      content="Tap to play Squid Game as Yeonghee!"
    />

    <!-- Telegram WebApp Script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <!-- Enhanced Telegram WebApp Initialization -->
    <script>
      // Enhanced Telegram WebApp initialization with better error handling
      window.telegramWebAppReady = false;
      window.telegramWebApp = null;
      
      // Wait for Telegram WebApp to be fully loaded
      function initializeTelegramWebApp() {
        return new Promise((resolve) => {
          if (window.Telegram && window.Telegram.WebApp) {
            window.telegramWebApp = window.Telegram.WebApp;
            
            // Expand the WebApp to full height
            window.telegramWebApp.expand();
            
            // Enable closing confirmation
            window.telegramWebApp.enableClosingConfirmation();
            
            // Set header color to match game theme
            window.telegramWebApp.setHeaderColor('#250a1f');
            
            // Mark as ready
            window.telegramWebAppReady = true;
            
            console.log("‚úÖ Telegram WebApp initialized successfully");
            console.log("üì± WebApp version:", window.telegramWebApp.version);
            console.log("üì± Platform:", window.telegramWebApp.platform);
            console.log("üì± InitData available:", !!window.telegramWebApp.initData);
            
            resolve(true);
          } else {
            console.log("‚ö†Ô∏è Telegram WebApp not available, using fallback mode");
            resolve(false);
          }
        });
      }
      
      // Initialize immediately if available, otherwise wait
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeTelegramWebApp);
      } else {
        initializeTelegramWebApp();
      }
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Gugi&display=swap"
      rel="stylesheet"
    />
    
    <!-- Preload critical images for faster loading -->
    <link rel="preload" href="./images/polling.png" as="image" />
    <link rel="preload" href="./image/bg.png" as="image" />
    <link rel="preload" href="./image/character.png" as="image" />
    <link rel="preload" href="./image/sole1.png" as="image" />
    <link rel="preload" href="./image/ruby.svg" as="image" />
    <link rel="preload" href="./image/money.svg" as="image" />

    <style>
      .gradient-bg {
        background: linear-gradient(
          360deg,
          rgba(211, 47, 181, 0) 3.4%,
          #250a1f 98.64%
        );
      }

      .card-bg {
        background: radial-gradient(
          50% 50% at 50% 50%,
          #450832 0%,
          #2e032c 100%
        );
        border: 1px solid rgba(215, 12, 163, 0.3);
        box-shadow: inset 0px 1px 4px 0px rgba(70, 13, 55, 0.69);
      }

      /* Custom Progress Bar Styles */
      .custom-progress-bg {
        background-color: #2e032c;
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
      }

      .custom-progress-fill {
        background: linear-gradient(
          90deg,
          #ff6b8b 0%,
          #ff4081 50%,
          #ff6b8b 100%
        );
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease-in-out;
        position: relative;
        box-shadow: 0 0 8px rgba(255, 107, 139, 0.4);
      }

      .custom-progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(255, 255, 255, 0.3) 50%,
          transparent 100%
        );
        animation: shimmer 2s infinite;
      }

      .custom-progress-fill::before {
        content: "";
        position: absolute;
        top: 1px;
        left: 1px;
        right: 1px;
        height: 40%;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.4) 0%,
          rgba(255, 255, 255, 0.1) 100%
        );
        border-radius: 3px;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }

        50% {
          transform: translateX(100%);
        }

        100% {
          transform: translateX(200%);
        }
      }

      .progress-interactive {
        cursor: pointer;
      }

      .progress-interactive:hover .custom-progress-fill {
        box-shadow: 0 0 12px rgba(255, 107, 139, 0.6);
      }

      body {
        font-family: "Gugi", sans-serif;
      }

      /* Loading Screen Styles */
      .loading-dots {
        display: flex;
        gap: 8px;
      }

      .dot {
        width: 12px;
        height: 12px;
        background-color: #ff6b8b;
        border-radius: 50%;
        animation: loadingDots 1s infinite ease-in-out;
        will-change: transform, opacity;
      }

      .dot:nth-child(1) {
        animation-delay: 0s;
      }

      .dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes loadingDots {
        0%, 70%, 100% {
          transform: scale(1);
          opacity: 0.6;
        }
        35% {
          transform: scale(1.4);
          opacity: 1;
        }
      }

      /* Character and Sole Press Animation - ENHANCED */
      .character-container {
        transition: all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        z-index: 50; /* Ensure character is above sole */
        position: relative;
      }

      .character-container.pressed {
        transform: translateY(6px) scale(0.95);
      }

      /* Enhanced Character Animations */
     

      .character-container.shake {
        animation: characterShake 0.5s ease-in-out;
      }

      



      /* Character Shake Animation */
      @keyframes characterShake {
        0%, 100% {
          transform: translateX(0);
        }
        10% {
          transform: translateX(-3px) rotate(-1deg);
        }
        20% {
          transform: translateX(3px) rotate(1deg);
        }
        30% {
          transform: translateX(-3px) rotate(-1deg);
        }
        40% {
          transform: translateX(3px) rotate(1deg);
        }
        50% {
          transform: translateX(-2px) rotate(-0.5deg);
        }
        60% {
          transform: translateX(2px) rotate(0.5deg);
        }
        70% {
          transform: translateX(-1px) rotate(-0.25deg);
        }
        80% {
          transform: translateX(1px) rotate(0.25deg);
        }
        90% {
          transform: translateX(-0.5px);
        }
      }



      /* Particle Effects for Character */
      .character-particles {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        pointer-events: none;
        z-index: 45;
      }

      .particle {
        position: absolute;
        width: 6px;
        height: 6px;
        background: radial-gradient(circle, #ff6b8b 0%, #ff4081 100%);
        border-radius: 50%;
        opacity: 0;
        animation: particleFloat 1.5s ease-out forwards;
      }

      .particle.golden {
        background: radial-gradient(circle, #ffd700 0%, #ffb300 100%);
        width: 8px;
        height: 8px;
        animation: goldenParticleFloat 2s ease-out forwards;
      }

      @keyframes particleFloat {
        0% {
          transform: translate(0, 0) scale(0);
          opacity: 0;
        }
        20% {
          transform: translate(var(--dx), var(--dy)) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(calc(var(--dx) * 3), calc(var(--dy) * 3)) scale(0);
          opacity: 0;
        }
      }

      @keyframes goldenParticleFloat {
        0% {
          transform: translate(0, 0) scale(0) rotate(0deg);
          opacity: 0;
        }
        15% {
          transform: translate(var(--dx), var(--dy)) scale(1.2) rotate(90deg);
          opacity: 1;
        }
        100% {
          transform: translate(calc(var(--dx) * 4), calc(var(--dy) * 4)) scale(0) rotate(360deg);
          opacity: 0;
        }
      }

      /* Heart Effect for Special Taps */
    
      /* Energy Wave Effect */
      .energy-wave {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        border: 3px solid #ff6b8b;
        border-radius: 50%;
        opacity: 0;
        pointer-events: none;
        z-index: 40;
        animation: energyWave 0.8s ease-out forwards;
      }

      .energy-wave.golden {
        border-color: #ffd700;
        animation: goldenEnergyWave 1s ease-out forwards;
      }

      @keyframes energyWave {
        0% {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 0.8;
        }
        100% {
          transform: translate(-50%, -50%) scale(3);
          opacity: 0;
        }
      }

      @keyframes goldenEnergyWave {
        0% {
          transform: translate(-50%, -50%) scale(0.3);
          opacity: 1;
          border-width: 4px;
        }
        50% {
          opacity: 0.6;
          border-width: 2px;
        }
        100% {
          transform: translate(-50%, -50%) scale(4);
          opacity: 0;
          border-width: 1px;
        }
      }

      #sole {
        transition: all 0.08s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        z-index: 10; /* Lower than character */
      }

      #sole.pressed {
        transform: translateY(8px) scale(0.98);
      }

      /* Light Effect Animation */
      .light-effect {
        position: absolute;
        bottom: -145px;
        left: 50%;
        transform: translateX(-49.5%);
        width: 100%;
        height: 820px;
        background-image: url("./image/light.png");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        opacity: 0;
        z-index: 1; /* Below everything else */
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .light-effect.show {
        opacity: 1;
      }

      /* Coin Flying Animation */
      @keyframes coinFly {
        0% {
          transform: translate(0, 0) scale(0.8) rotate(0deg);
          opacity: 0;
        }
        10% {
          transform: translate(0, -30px) scale(1.8) rotate(45deg);
          opacity: 1;
        }
        50% {
          transform: translate(
              calc(var(--tx) * 0.5),
              calc(var(--ty) * 0.5 - 80px)
            )
            scale(1.5) rotate(180deg);
          opacity: 0.9;
        }
        80% {
          transform: translate(calc(var(--tx) * 0.8), calc(var(--ty) * 0.8))
            scale(1.2) rotate(270deg);
          opacity: 0.7;
        }
        100% {
          transform: translate(var(--tx), var(--ty)) scale(1) rotate(360deg);
          opacity: 0;
        }
      }

      /* Flying Score Text Animation */
      @keyframes scoreTextFly {
        0% {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, -70px) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -150px) scale(1);
          opacity: 0;
        }
      }

      .flying-score-text {
        position: fixed;
        font-family: "Gugi", sans-serif;
        font-size: 28px;
        font-weight: bold;
        color: #ffd93d;
        text-shadow: 
          2px 2px 4px rgba(0, 0, 0, 0.8),
          0 0 10px rgba(255, 217, 61, 0.6),
          0 0 20px rgba(255, 217, 61, 0.4);
        pointer-events: none;
        z-index: 9998;
        animation: scoreTextFly 1.5s ease-out forwards;
        user-select: none;
      }

      .flying-score-text.special {
        color: #ff6b8b;
        font-size: 32px;
        text-shadow: 
          2px 2px 4px rgba(0, 0, 0, 0.8),
          0 0 10px rgba(255, 107, 139, 0.8),
          0 0 20px rgba(255, 107, 139, 0.6),
          0 0 30px rgba(255, 107, 139, 0.4);
      }

      .flying-coin {
        position: fixed;
        width: 35px;
        height: 35px;
        background: url("./image/money.svg") no-repeat center;
        background-size: contain;
        pointer-events: none;
        z-index: 9999;
        animation: coinFly 2.5s ease-out forwards;
      }

      /* Level Up Popup Styles */
      .level-up-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .level-up-popup.show {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .level-up-content {
        background: linear-gradient(135deg, #2e032c 0%, #450832 100%);
        border: 2px solid rgba(215, 12, 163, 0.5);
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        max-width: 300px;
        width: 90%;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      }

      .level-up-emoji {
        font-size: 48px;
        margin-bottom: 15px;
      }

      .level-up-title {
        font-size: 24px;
        font-weight: bold;
        color: #ff6b8b;
        margin-bottom: 10px;
      }

      .level-up-description {
        color: white;
        margin-bottom: 20px;
        font-size: 14px;
      }

      .level-up-button {
        background: linear-gradient(90deg, #ff6b8b 0%, #ff4081 100%);
        border: none;
        border-radius: 10px;
        padding: 12px 30px;
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s ease;
      }

      .level-up-button:hover {
        transform: scale(1.05);
      }

      /* Tap area styles */
      .tap-area {
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      /* Flash effect for tap feedback */
      @keyframes flash {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
        100% {
          opacity: 1;
        }
      }

      .flash {
        animation: flash 0.2s ease-out;
      }

      /* Progress Bar Styles from index.html */
      .progress-bar {
        background: linear-gradient(90deg, #e45f90 0%, #f06292 100%);
        height: 8px;
      }

      .progress-icon {
        position: absolute;
        border-radius: 0.5px;
        background: linear-gradient(0deg, #bac1d6 0.01%, #ffffff 99.98%);
        width: 5.5px;
        height: 14px;
        top: -1px;
        transition: left 0.3s ease;
      }

      .level-bars {
        background-color: #facc15;
        height: 12px;
      }
      .level-bars-mt {
        background-color: #bf5206;
        height: 12px;
      }



      /* HP Progress Container */
      .hp-progress-container {
        position: relative;
        width: 100%;
        height: 12px;
        background: rgba(215, 12, 163, 0.42);
        border-radius: 4px;
        overflow: hidden;
      }

      /* HP Level Progress Container */
      .hp-level-progress-container {
        position: relative;
        width: 100%;
        height: 12px;
        background: rgba(215, 12, 163, 0.42);
        border-radius: 4px;
        overflow: hidden;
      }

      /* LP Level Progress Container */
      .lp-level-progress-container {
        position: relative;
        width: 100%;
        height: 12px;
        background: rgba(215, 12, 163, 0.42);
        border-radius: 4px;
        overflow: hidden;
      }

      /* Target indicator for coin flights */
      .coin-target-indicator {
        box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        border: 1px solid rgba(255, 215, 0, 0.4);
        animation: targetPulse 2s infinite;
      }

      @keyframes targetPulse {
        0% {
          box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }
        50% {
          box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }
        100% {
          box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }
      }

      /* Level Progress Icon */
      .level-progress-icon {
        position: absolute;
        border-radius: 0.5px;
        background: linear-gradient(0deg, #bac1d6 0.01%, #ffffff 99.98%);
        width: 5.5px;
        height: 14px;
        top: -1px;
        transition: left 0.3s ease;
      }

      /* Mobile adjustments */
      @media screen and (max-width: 428px) {
        .level-bars {
          height: 8px;
        }
        .level-bars-mt {
        background-color: #bf5206;
        height: 12px;
      }
        .progress-icon {
          height: 12px;
        }

        .level-progress-icon {
          height: 12px;
        }
      }

      

      /* Auto Earn Button Styles */
      #auto-earn-button {
        transition: all 0.3s ease;
        cursor: pointer;
        z-index: 100;
        position: relative;
        border: none;
        background: transparent;
      }

      #auto-earn-button:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px rgba(255, 107, 139, 0.4);
      }

      #auto-earn-button.active {
        background: linear-gradient(
          135deg,
          #ff6b8b 0%,
          #ff4081 100%
        ) !important;
        border: 2px solid #ff6b8b !important;
        box-shadow: 0 0 20px rgba(255, 107, 139, 0.6),
          inset 0 0 10px rgba(255, 255, 255, 0.2) !important;
        animation: pulse-glow 2s infinite;
      }

      #auto-earn-button.active img {
        filter: brightness(1.2) drop-shadow(0 0 5px rgba(255, 255, 255, 0.8));
      }

      /* Navigation item containing auto-earn button */
      #nav-auto-earn {
        padding: 0 !important;
      }

      #nav-auto-earn.active #auto-earn-button {
        background: linear-gradient(
          135deg,
          #ff6b8b 0%,
          #ff4081 100%
        ) !important;
        border: 2px solid #ff6b8b !important;
        box-shadow: 0 0 20px rgba(255, 107, 139, 0.6),
          inset 0 0 10px rgba(255, 255, 255, 0.2) !important;
        animation: pulse-glow 2s infinite;
      }

      #nav-auto-earn.active #auto-earn-button img {
        filter: brightness(1.2) drop-shadow(0 0 5px rgba(255, 255, 255, 0.8));
      }

      @keyframes pulse-glow {
        0% {
          box-shadow: 0 0 20px rgba(255, 107, 139, 0.6),
            inset 0 0 10px rgba(255, 255, 255, 0.2);
        }
        50% {
          box-shadow: 0 0 30px rgba(255, 107, 139, 0.8),
            inset 0 0 15px rgba(255, 255, 255, 0.3);
        }
        100% {
          box-shadow: 0 0 20px rgba(255, 107, 139, 0.6),
            inset 0 0 10px rgba(255, 255, 255, 0.2);
        }
      }

      /* Visual Effects Functions */
      .show-floating-text {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #ffd93d;
        font-size: 24px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 10001;
        animation: floatUp 2s ease-out forwards;
      }

      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0px) scale(1);
        }
        50% {
          opacity: 1;
          transform: translateY(-30px) scale(1.1);
        }
        100% {
          opacity: 0;
          transform: translateY(-60px) scale(0.8);
        }
      }

      .show-multiplier-effect {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #ffd93d;
        font-size: 24px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 10001;
        animation: floatUp 2s ease-out forwards;
      }

      /* Bottom Navigation Active State */
      .nav-item {
        transition: all 0.3s ease;
        cursor: pointer;
        padding: 6px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 40px;
        min-height: 40px;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }

      .nav-item.active {
        background: rgba(255, 107, 139, 0.2);
        box-shadow: 0 0 15px rgba(255, 107, 139, 0.4);
        border: 1px solid rgba(255, 107, 139, 0.3);
      }

      .nav-item.active img {
        filter: brightness(1.5) drop-shadow(0 0 8px rgba(255, 107, 139, 0.8));
        transform: scale(1.1);
      }

      .nav-item:hover {
        background: rgba(255, 107, 139, 0.1);
      }

      .nav-item:active {
        transform: scale(0.95);
      }

      .nav-item span {
        transition: all 0.3s ease;
        font-family: "Gugi", sans-serif;
      }

      /* Character Faint Animation (when HP = 0) */
      .character-container.faint {
        animation: characterFaint 2s ease-in-out;
        filter: grayscale(0.7) brightness(0.6);
      }

      @keyframes characterFaint {
        0% {
          transform: translateY(0px) scale(1) rotate(0deg);
          opacity: 1;
        }
        30% {
          transform: translateY(-5px) scale(0.98) rotate(-2deg);
          opacity: 0.8;
        }
        60% {
          transform: translateY(2px) scale(0.95) rotate(1deg);
          opacity: 0.6;
        }
        100% {
          transform: translateY(0px) scale(0.9) rotate(0deg);
          opacity: 0.4;
        }
      }

      /* HP Zero overlay effect */
      .hp-zero-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, rgba(255,0,0,0.1) 0%, rgba(0,0,0,0.3) 100%);
        z-index: 9997;
        pointer-events: none;
        opacity: 0;
        animation: hpZeroOverlay 3s ease-in-out forwards;
      }

      @keyframes hpZeroOverlay {
        0% { opacity: 0; }
        50% { opacity: 1; }
        100% { opacity: 0; }
      }
    </style>
  </head>

  <body class="bg-gray-900 ">
    <div
      class="md:w-[375px] md:max-w-[375px] w-full relative h-screen rounded-[20px] mx-auto gradient-bg p-[16px]"
    >
      <!-- Loading Screen -->
      <div id="loading-screen" class="absolute top-0 left-0 right-0 z-[99999] bg-gray-900 rounded-[20px] flex flex-col items-center justify-center" style="bottom: 0px;">
        <img 
          src="./images/polling.png" 
          alt="Loading..." 
          class="w-full h-full object-cover rounded-[20px] absolute top-0 left-0"
        />
        <!-- Loading Text Overlay -->
        <div class="absolute inset-0 flex flex-col items-center justify-start pt-16 bg-black bg-opacity-40 rounded-[20px]">
          <div class="text-center mb-8">
            <h1 class="text-white text-2xl font-bold mb-2 gugi-font">Younghee Game</h1>
          </div>
          
          <!-- Loading Animation -->
          <div class="flex flex-col items-center">
            <div class="loading-dots mb-4">
              <span class="dot"></span>
              <span class="dot"></span>
              <span class="dot"></span>
            </div>
            <p id="loading-text" class="text-white text-sm gugi-font">Loading...</p>
          </div>
        </div>
      </div>

      <!-- Immediate loading screen check -->
      <script>
        (function() {
          // Check URL parameters immediately
          const urlParams = new URLSearchParams(window.location.search);
          const fromPage = urlParams.get('from');
          const hasSeenLoading = sessionStorage.getItem('hasSeenLoadingScreen');
          
          console.log('üöÄ Immediate check - from:', fromPage, 'hasSeenLoading:', hasSeenLoading);
          
          // If coming from another page or already seen loading, hide immediately
          if (fromPage === 'exchange' || fromPage === 'point' || hasSeenLoading) {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
              loadingScreen.style.display = 'none';
              console.log('üöÄ Loading screen hidden immediately - from:', fromPage || 'already seen');
            }
          }
        })();
      </script>

      <img
        class="absolute rounded-[20px] top-0 left-0 w-full h-screen z-[-1] bottom-0 right-0  object-center"
        src="./image/bg.png"
        alt=""
      />
      <div class="flex flex-col gap-[8px]">
        <!-- Avatar, User ID, Ruby and Money Display Section -->
        <div class="flex justify-between items-center gap-2 mb-2">
          <!-- Avatar and User ID -->
          <div class="flex flex-col items-center gap-1">
            <div
              class="w-8 h-8 rounded-full bg-gradient-to-br from-green-400 to-yellow-400 flex items-center justify-center text-sm font-bold text-white"
            >
              U
            </div>
            <span class="text-white text-xs font-semibold user-id">Loading...</span>
          </div>
          
          <!-- Ruby Display -->
          <div
            class="flex flex-1 h-[30px] px-[4px] pr-[12px] py-[4px] gap-[8px] rounded-full card-bg items-center"
          >
            <img src="./image/ruby.svg" class="w-[20px]" alt="" />

            <span
              class="gugi-font text-[14px] leading-[22px] tracking-[0%] align-middle text-white"
              >0</span
            >
          </div>

          <!-- Money Display -->
          <div
            class="flex flex-1 h-[30px] px-[4px] pr-[12px] py-[4px] gap-[8px] rounded-full card-bg items-center"
          >
            <img src="./image/money.svg" alt="" />

            <span
              id="coin-earn"
              class="gugi-font text-[14px] leading-[22px] tracking-[0%] align-middle text-white"
              >0</span
            >
          </div>
        </div>

        <div
          class="card-bg gradient-bg p-[12px] rounded-[20px] w-full h-[142.5px]"
        >
          <div class="flex flex-col gap-[8px]">
            <div class="flex justify-between">
              <div class="flex flex-col gap-[10px] w-full">
                <div class="flex justify-between">
                  <p
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-[#FF6B8B]"
                  >
                    HP
                  </p>
                  <p
                    id="hp-display"
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
                  >
                    100/100
                  </p>
                </div>
                <!-- HP Progress Bar -->
                <div class="hp-progress-container">
                  <div
                    class="progress-bar"
                    id="hp-bar"
                    style="width: 100%; transition: width 0.3s ease-in-out"
                  ></div>
                  <div class="progress-icon" style="left: 100%"></div>
                </div>
              </div>

            </div>
            <img src="./image/divider.svg" alt="" />
            <div class="flex justify-between items-center">
              <div class="w-[143px] flex flex-col gap-[9px]">
                <div class="flex justify-between">
                  <p
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-[#FF6B8B]"
                  >
                    HP
                  </p>
                  <p
                    id="hp-level-display"
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
                  >
                    1
                  </p>
                </div>

                <!-- HP Level Progress Bar -->
                <div class="hp-level-progress-container">
                  <div
                    class="level-bars"
                    id="hp-level-bar"
                    style="width: 0%; transition: width 0.3s ease-in-out"
                  ></div>
                  <div class="level-progress-icon" style="left: 0%"></div>
                </div>
              </div>

              <div class="w-[143px] flex flex-col gap-[9px]">
                <div class="flex justify-between">
                  <p
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-[#FF6B8B]"
                  >
                    MT 
                  </p>
                  <p
                    id="lp-level-display"
                    class="font-normal text-[13px] leading-[20px] tracking-[0%] text-center align-middle text-white"
                  >
                    1
                  </p>
                </div>

                <!-- LP Level Progress Bar -->
                <div class="lp-level-progress-container">
                  <div
                    class="level-bars-mt "
                    id="lp-level-bar"
                    style="width: 0%; transition: width 0.3s ease-in-out"
                  ></div>
                  <div class="level-progress-icon" style="left: 0%"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="w-full flex justify-end">

        </div>
      </div>
      <div class="absolute bottom-[13%] left-[-12px] p-[10px]">
        <div class="relative flex flex-col justify-between items-center">
          <div
            class="absolute top-[-150px] left-[20px] right-0 flex justify-center character-container"
          >
            <img
              id="younghee"
              class="w-[149px] h-[224px] tap-area"
              src="./image/character.png"
              alt=""
            />
          </div>
          <div class="relative">
            <!-- Light effect element -->
            <div id="light-effect" class="light-effect"></div>
            <img id="sole" class="tap-area" src="./image/sole1.png" alt="" />
          </div>
        </div>
      </div>
      <div class="absolute bottom-[20px] left-0 right-0 flex justify-center">
  <div
        id="bottom-navigation"
        class=" gradient-bg card-bg  md:w-[360px] w-full h-[72px] rounded-full p-[24px] flex justify-center items-center"
        style="z-index: 999; pointer-events: auto;"
      >
        <ul class="flex justify-between items-center gap-[20px] w-full">
          <li class="nav-item active flex flex-col items-center gap-[4px]" id="nav-earn">
            <img src="./image/earn.svg" alt="" class="w-[20px] h-[20px]" />
            <span class="text-[10px] text-white font-medium">Earn</span>
          </li>
          <li class="nav-item flex flex-col items-center gap-[4px]" id="nav-exchange">
            <img src="./image/exchange.svg" alt="" class="w-[20px] h-[20px]" />
            <span class="text-[10px] text-white font-medium">Exchange</span>
          </li>
          <li class="nav-item flex flex-col items-center gap-[4px]" id="nav-auto-earn">
            <button
              id="auto-earn-button"
              class="gradient-bg card-bg w-[40px] h-[40px] rounded-lg flex items-center justify-center"
            >
              <img src="./image/button.svg" alt="" class="w-[20px] h-[20px]" />
            </button>
            <span class="text-[10px] text-white font-medium">Auto</span>
          </li>
          <li class="nav-item flex flex-col items-center gap-[4px]" id="nav-point">
            <img src="./image/point.svg" alt="" class="w-[20px] h-[20px]" />
            <span class="text-[10px] text-white font-medium">Point</span>
          </li>
          <li class="nav-item flex flex-col items-center gap-[4px]" id="nav-help">
            <img src="./image/help.svg" alt="" class="w-[20px] h-[20px]" />
            <span class="text-[10px] text-white font-medium">Help</span>
          </li>
        </ul>
      </div>
      </div>
    
    </div>

      
      </div>
    </div>

    <!-- Level Up Popup -->
    <div id="level-up-popup" class="level-up-popup">
      <div class="level-up-content">
        <div class="level-up-emoji">üéâ</div>
        <div class="level-up-text-container">
          <div class="level-up-title">Level Up!</div>
          <div class="level-up-description">
            New rewards unlocked and stronger power await you.
          </div>
        </div>
        <button
          id="level-up-confirm-btn"
          class="level-up-button"
          onclick="closeLevelUpPopup()"
        >
          <span class="level-up-button-text">Confirm</span>
        </button>
      </div>
    </div>

    <script>
      // =====================
      // Audio System
      // =====================
      
      // Create audio objects for sound effects
      const coinSound = new Audio('./images/retro-coin-4-236671.mp3');
      const crashSound = new Audio('./images/box-crash-106687.mp3');
      const levelUpSound = new Audio('./images/Game-level-up-sound-effect.mp3');
      
      // Configure audio settings
      coinSound.volume = 0.7; // Adjust volume (0.0 to 1.0)
      crashSound.volume = 0.8;
      levelUpSound.volume = 0.9;
      
      // Preload audio files
      coinSound.preload = 'auto';
      crashSound.preload = 'auto';
      levelUpSound.preload = 'auto';
      
      // Function to play coin sound with error handling
      function playCoinSound() {
        try {
          // Check if audio context exists and resume if suspended
          if (window.AudioContext || window.webkitAudioContext) {
            const audioCtx = window.audioContext || new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') {
              audioCtx.resume().then(() => {
                console.log('üîä Audio context resumed for coin sound');
              }).catch(error => {
                console.log('‚ùå Failed to resume audio context:', error);
              });
            }
          }
          
          coinSound.currentTime = 0; // Reset to beginning for rapid taps
          const playPromise = coinSound.play();
          
          if (playPromise !== undefined) {
            playPromise.then(() => {
              // Audio played successfully
              console.log('üîä Coin sound played successfully');
            }).catch(error => {
              console.log('üîä Coin sound play failed:', error);
              // Try to play again after a short delay
              setTimeout(() => {
                coinSound.play().catch(e => console.log('üîä Retry coin sound failed:', e));
              }, 100);
            });
          }
        } catch (error) {
          console.log('üîä Coin sound error:', error);
        }
      }
      
      // Function to play crash sound with error handling
      function playCrashSound() {
        try {
          crashSound.currentTime = 0; // Reset to beginning
          crashSound.play().catch(error => {
            console.log('Crash sound play failed:', error);
          });
        } catch (error) {
          console.log('Crash sound error:', error);
        }
      }
      
      // Function to play level up sound with error handling
      function playLevelUpSound() {
        try {
          levelUpSound.currentTime = 0; // Reset to beginning
          levelUpSound.play().catch(error => {
            console.log('Level up sound play failed:', error);
          });
        } catch (error) {
          console.log('Level up sound error:', error);
        }
      }

      // =====================
      // Loading Screen Management
      // =====================
      
      // Check if user is coming from another page (will be set later when urlParams is available)
      let isFromOtherPage = false;
      
      // Loading messages in English
      const loadingMessages = [
        "Loading...",
        "Preparing game...",
        "Welcome!"
      ];
      
      let currentMessageIndex = 0;
      let loadingTextInterval;
      
      // Animate loading text
      function animateLoadingText() {
        const loadingTextElement = document.getElementById('loading-text');
        if (loadingTextElement && currentMessageIndex < loadingMessages.length) {
          loadingTextElement.style.opacity = '0';
          setTimeout(() => {
            loadingTextElement.textContent = loadingMessages[currentMessageIndex];
            loadingTextElement.style.opacity = '1';
            currentMessageIndex++;
          }, 150);
        }
      }
      
      // Start loading text animation
      function startLoadingAnimation() {
        const loadingTextElement = document.getElementById('loading-text');
        if (loadingTextElement) {
          loadingTextElement.style.transition = 'opacity 0.2s ease-in-out';
          loadingTextInterval = setInterval(animateLoadingText, 500);
        }
      }
      
      // Hide loading screen when page is fully loaded
      function hideLoadingScreenIfNeeded() {
        const loadingScreen = document.getElementById('loading-screen');
        if (!loadingScreen) {
          console.log('üöÄ Loading screen element not found');
          return;
        }
        
        // Check if coming from another page using URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const fromPage = urlParams.get('from');
        isFromOtherPage = fromPage === 'exchange' || fromPage === 'point';
        
        console.log('üîç URL params:', window.location.search);
        console.log('üîç From page:', fromPage);
        console.log('üîç Is from other page:', isFromOtherPage);
        
        // Check if user has already seen loading screen in this session
        const hasSeenLoading = sessionStorage.getItem('hasSeenLoadingScreen');
        console.log('üîç Has seen loading:', hasSeenLoading);
        
        // If coming from another page or already seen loading, hide loading screen immediately
        if (isFromOtherPage || hasSeenLoading) {
          console.log('üöÄ Skipping loading screen - from:', fromPage || 'already seen');
          loadingScreen.style.display = 'none';
          return;
        }
        
        // Mark that user has seen the loading screen
        sessionStorage.setItem('hasSeenLoadingScreen', 'true');
        console.log('‚úÖ Marked loading screen as seen');
        
        // Start loading text animation for first-time visitors
        startLoadingAnimation();
        
        // Keep loading screen visible for 1.5 seconds (reduced from 3.5)
        setTimeout(() => {
          // Clear loading text animation
          if (loadingTextInterval) {
            clearInterval(loadingTextInterval);
          }
          
          // Add fade out animation with transform for better performance
          loadingScreen.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
          loadingScreen.style.opacity = '0';
          loadingScreen.style.transform = 'scale(0.95)';
          
          // Remove from DOM after animation completes
          setTimeout(() => {
            loadingScreen.style.display = 'none';
            console.log('‚úÖ Loading screen hidden after animation');
          }, 400);
        }, 1500); // Reduced to 1.5 seconds
      }
      
      // Call the function when page loads
      window.addEventListener('load', hideLoadingScreenIfNeeded);
      
      // Also call it when DOM is ready (fallback)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', hideLoadingScreenIfNeeded);
      } else {
        // DOM is already ready, call immediately
        hideLoadingScreenIfNeeded();
      }

      // =====================
      // 0. Telegram Integration & API Sync
      // =====================

      // Get Telegram user ID from URL parameters or Telegram WebApp
      let telegramUserId = null;
      let telegramUserData = null; // Store full user data

      // Configure Telegram WebApp to disable close confirmation
      if (window.Telegram && window.Telegram.WebApp) {
        const tg = window.Telegram.WebApp;
        
        // Disable close confirmation popup
        tg.enableClosingConfirmation = false;
        
        // Set app as ready
        tg.ready();
        
        // Expand the app to full height
        tg.expand();
        
        console.log("üì± Telegram WebApp configured - close confirmation disabled");
      }

      function getTelegramUserId() {
        console.log("üîç getTelegramUserId() called");
        console.log("üîç Current telegramUserData:", telegramUserData);
        
        // Game state remains server-only to prevent hacking
        
        // 1. Check if already cached in memory
        if (telegramUserId) {
          console.log("üì± Using cached telegramUserId:", telegramUserId);
          console.log("üì± Current telegramUserData:", telegramUserData);
          return telegramUserId;
        }
        
        // 2. Try to get from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const userIdFromUrl = urlParams.get("userId");

        if (userIdFromUrl) {
          telegramUserId = userIdFromUrl;
          console.log("üì± Telegram User ID from URL:", telegramUserId);
          // Also save to sessionStorage for cross-tab sharing
          sessionStorage.setItem('telegramUserId', telegramUserId);
          
          // Try to get additional user data from URL
          const username = urlParams.get("username");
          const firstName = urlParams.get("first_name");
          if (username || firstName) {
            telegramUserData = {
              id: telegramUserId,
              username: username,
              first_name: firstName
            };
            console.log("üì± User data from URL:", telegramUserData);
            sessionStorage.setItem('telegramUserData', JSON.stringify(telegramUserData));
          }
          
          return telegramUserId;
        }

        // 3. Try to get from sessionStorage (for cross-tab sharing)
        const userIdFromSession = sessionStorage.getItem('telegramUserId');
        if (userIdFromSession) {
          telegramUserId = userIdFromSession;
          console.log("üì± Telegram User ID from sessionStorage:", telegramUserId);
          
          // Also try to restore user data from sessionStorage
          const userDataFromSession = sessionStorage.getItem('telegramUserData');
          if (userDataFromSession) {
            try {
              telegramUserData = JSON.parse(userDataFromSession);
              console.log("üì± User data from sessionStorage:", telegramUserData);
            } catch (e) {
              console.log("‚ö†Ô∏è Failed to parse user data from sessionStorage");
            }
          }
          
          return telegramUserId;
        }

        // 3.5. Try to get from localStorage (for long-term persistence)
        const userIdFromLocal = localStorage.getItem('telegramUserId');
        if (userIdFromLocal) {
          telegramUserId = userIdFromLocal;
          console.log("üì± Telegram User ID from localStorage:", telegramUserId);
          
          // Check if user was recently active (within last 30 days)
          const lastActiveTimestamp = localStorage.getItem('lastActiveTimestamp');
          const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
          
          if (lastActiveTimestamp && parseInt(lastActiveTimestamp) > thirtyDaysAgo) {
            console.log("‚úÖ User was recently active, restoring session");
            
            // Also try to restore user data from localStorage
            const userDataFromLocal = localStorage.getItem('telegramUserData');
            if (userDataFromLocal) {
              try {
                telegramUserData = JSON.parse(userDataFromLocal);
                console.log("üì± User data from localStorage:", telegramUserData);
                
                // Also save to sessionStorage for current session
                sessionStorage.setItem('telegramUserId', telegramUserId);
                sessionStorage.setItem('telegramUserData', JSON.stringify(telegramUserData));
                
                // Update timestamp
                const timestamp = Date.now();
                localStorage.setItem('lastActiveTimestamp', timestamp.toString());
                sessionStorage.setItem('lastActiveTimestamp', timestamp.toString());
                
              } catch (e) {
                console.log("‚ö†Ô∏è Failed to parse user data from localStorage");
              }
            }
            
            return telegramUserId;
          } else {
            console.log("‚ö†Ô∏è User data is too old (>30 days), will create new session");
            // Clear old data
            localStorage.removeItem('telegramUserId');
            localStorage.removeItem('telegramUserData');
            localStorage.removeItem('lastActiveTimestamp');
          }
        }

        // 4. Try to get from Enhanced Telegram WebApp first
        if (window.telegramWebAppReady && window.telegramWebApp) {
          const webApp = window.telegramWebApp;
          console.log("üîç Enhanced Telegram WebApp available:", webApp);
          console.log("üîç WebApp initData:", webApp.initData);
          console.log("üîç WebApp initDataUnsafe:", webApp.initDataUnsafe);

          if (webApp.initDataUnsafe && webApp.initDataUnsafe.user) {
            telegramUserId = webApp.initDataUnsafe.user.id.toString();
            telegramUserData = webApp.initDataUnsafe.user; // Store in memory only

            console.log("üì± Telegram User ID from Enhanced WebApp:", telegramUserId);
            console.log("üë§ User info:", webApp.initDataUnsafe.user);
            console.log(
              "üë§ Username:",
              telegramUserData.username || "No username"
            );
            console.log(
              "üë§ First name:",
              telegramUserData.first_name || "No first name"
            );
            
            // Save to sessionStorage for cross-tab sharing
            sessionStorage.setItem('telegramUserId', telegramUserId);
            sessionStorage.setItem('telegramUserData', JSON.stringify(telegramUserData));
            return telegramUserId;
          }
        }
        
        // 5. Fallback to original Telegram WebApp
        if (
          typeof window !== "undefined" &&
          window.Telegram &&
          window.Telegram.WebApp &&
          window.Telegram.WebApp.initDataUnsafe &&
          window.Telegram.WebApp.initDataUnsafe.user
        ) {
          const webApp = window.Telegram.WebApp;
          telegramUserId = webApp.initDataUnsafe.user.id.toString();
          telegramUserData = webApp.initDataUnsafe.user; // Store in memory only

          console.log("üì± Telegram User ID from Fallback WebApp:", telegramUserId);
          console.log("üë§ User info:", webApp.initDataUnsafe.user);
          console.log(
            "üë§ Username:",
            telegramUserData.username || "No username"
          );
          console.log(
            "üë§ First name:",
            telegramUserData.first_name || "No first name"
          );

          // Save to both sessionStorage and localStorage for better persistence
          sessionStorage.setItem('telegramUserId', telegramUserId);
          sessionStorage.setItem('telegramUserData', JSON.stringify(telegramUserData));
          localStorage.setItem('telegramUserId', telegramUserId);
          localStorage.setItem('telegramUserData', JSON.stringify(telegramUserData));
          
          // Also save a timestamp to track when the user was last active
          const timestamp = Date.now();
          localStorage.setItem('lastActiveTimestamp', timestamp.toString());
          sessionStorage.setItem('lastActiveTimestamp', timestamp.toString());
          
          console.log("üíæ User data saved to both session and local storage with timestamp:", new Date(timestamp));
          return telegramUserId;
        }

        // 6. Generate demo user ID as fallback (save to sessionStorage for consistency)
        telegramUserId = "demo_" + Math.random().toString(36).substr(2, 9);
        telegramUserData = {
          id: telegramUserId,
          first_name: "Demo User",
          username: null,
        };

        console.log("üì± Generated demo Telegram User ID (saving to sessionStorage):", telegramUserId);
        // Save to sessionStorage so other tabs can use the same ID
        sessionStorage.setItem('telegramUserId', telegramUserId);
        return telegramUserId;
      }

      // API functions for syncing with server
      async function syncGameStateToServer(gameState) {
        if (!telegramUserId) return;

        // CRITICAL: Special handling for HP=0 - highest priority sync
        const isHPZero = gameState.hp === 0;
        const isHPCritical = gameState.hp <= 0 || gameState.hp <= 10;
        
        try {
          if (isHPZero) {
            console.log(`üíÄ CRITICAL: Syncing HP=0 to database (IMMEDIATE PRIORITY)`);
          } else {
            console.log(`üîÑ Syncing game state to server (HP: ${gameState.hp}, Coins: ${gameState.coinCount}, Critical: ${isHPCritical})...`);
          }
          
          // FIXED: Ensure we send the correct data structure to server
          const syncData = {
            level: gameState.level || 1,
            hp: gameState.hp || 0,
            coinCount: gameState.coinCount || 0, // This is the ruby count
            coinEarn: gameState.coinEarn || 0,   // This is temporary coins during tapping
            smg: gameState.smg || 0, // Add SMG field
            lastRecover: gameState.lastRecover || Date.now(),
            lastZeroHP: gameState.lastZeroHP || null,
            timestamp: Date.now(),
            syncType: isHPZero ? 'hp_zero_critical' : (isHPCritical ? 'critical' : 'normal'),
            forceSync: isHPZero // Force immediate database write for HP=0
          };
          
          console.log("üì§ Sending sync data to server:", syncData);
          
          const response = await fetch(`/api/sync/${telegramUserId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(syncData),
          });

          if (response.ok) {
            const result = await response.json();
            
            if (isHPZero) {
              console.log("üíÄ HP=0 sync response:", result);
              // Verify HP=0 was actually saved
              if (result.success && result.data && result.data.hp === 0) {
                console.log("‚úÖ CONFIRMED: HP=0 successfully saved to database");
              } else {
                console.error("‚ùå CRITICAL ERROR: HP=0 was NOT saved correctly to database!");
                console.error("Database returned HP:", result.data?.hp);
                // Force retry for HP=0
                setTimeout(() => {
                  console.log("üîÑ FORCE RETRYING HP=0 sync...");
                  syncGameStateToServer(gameState);
                }, 500);
                return;
              }
            } else {
              console.log("‚úÖ Game state synced to server:", result);
              
              // IMPORTANT: Don't overwrite local state with server response during active gameplay
              // Only update if the server has newer/better data
              if (result.success && result.data) {
                const serverCoins = result.data.ruby || 0;
                const localCoins = gameState.coinCount || 0;
                
                console.log(`üîç Sync comparison - Local coins: ${localCoins}, Server coins: ${serverCoins}`);
                
                // Only update local state if server has more coins (to prevent data loss)
                if (serverCoins > localCoins) {
                  console.log("üìà Server has more coins - updating local state");
                  gameState.coinCount = serverCoins;
                  saveGameState(gameState);
                  updateUI(gameState);
                } else if (serverCoins < localCoins) {
                  console.log("‚ö†Ô∏è Server has fewer coins - keeping local state and retrying sync");
                  // Retry sync to ensure server gets the latest data
                  setTimeout(() => {
                    console.log("üîÑ Retrying sync to update server with latest coins...");
                    syncGameStateToServer(gameState);
                  }, 1000);
                } else {
                  console.log("‚úÖ Coins are in sync");
                }
              }
            }
            
            // Verify the sync was successful by checking returned data
            if (result.success && result.data) {
              console.log("‚úÖ Server confirmed HP:", result.data.hp, "Ruby:", result.data.ruby);
            }
          } else {
            console.error("‚ùå Failed to sync game state:", response.statusText);
            
            // CRITICAL: Always retry HP=0 syncs
            if (isHPZero) {
              console.log("üíÄ CRITICAL: Retrying HP=0 sync immediately...");
              setTimeout(() => syncGameStateToServer(gameState), 500);
            } else if (isHPCritical) {
              console.log("üîÑ Retrying critical HP sync...");
              setTimeout(() => syncGameStateToServer(gameState), 1000);
            }
          }
        } catch (error) {
          console.error("‚ùå Error syncing game state:", error);
          
          // CRITICAL: Always retry HP=0 syncs even on error
          if (isHPZero) {
            console.log("üíÄ CRITICAL ERROR: Retrying HP=0 sync after error...");
            setTimeout(() => syncGameStateToServer(gameState), 1000);
          } else if (isHPCritical) {
            console.log("üîÑ Retrying critical HP sync after error...");
            setTimeout(() => syncGameStateToServer(gameState), 2000);
          }
        }
      }

      async function loadGameStateFromServer() {
        if (!telegramUserId) return null;

        try {
          console.log(`üåê Loading game state from DATABASE for user: ${telegramUserId}`);
          const response = await fetch(`/api/user/${telegramUserId}`);

          if (response.ok) {
            const result = await response.json();
            if (result.success && result.data) {
              console.log("üì• Raw database data received:", result.data);
              console.log("üîç DEBUG: result.data.ruby value:", result.data.ruby);
              console.log("üîç DEBUG: typeof result.data.ruby:", typeof result.data.ruby);

              // Convert server data format to client format
              const serverState = {
                level: result.data.level || 1,
                hp: result.data.hp, // Don't provide default - preserve exact value from DB
                coinCount: result.data.ruby || 0, // Only ruby count needed
                lastRecover: result.data.lastRecover || Date.now(),
                lastZeroHP: result.data.lastZeroHP || null,
              };
              
              console.log("üîç DEBUG: serverState.coinCount after conversion:", serverState.coinCount);

              // CRITICAL: Preserve HP=0 from database
              if (result.data.hp === 0) {
                console.log("üíÄ DATABASE HP is 0 - PRESERVING zero HP state");
                serverState.hp = 0;
              } else if (result.data.hp === undefined || result.data.hp === null) {
                console.log("‚ö†Ô∏è DATABASE HP is undefined/null - setting to 0");
                serverState.hp = 0;
              } else if (result.data.hp < 0) {
                console.log("‚ö†Ô∏è DATABASE HP is negative - setting to 0");
                serverState.hp = 0;
              } else {
                console.log(`üíñ DATABASE HP preserved: ${result.data.hp}`);
                serverState.hp = result.data.hp;
              }

              console.log("‚úÖ Converted database state:", serverState);
              return serverState;
            } else {
              console.log("‚ùå No valid data in database response");
            }
          } else {
            console.log(`‚ùå Database request failed with status: ${response.status}`);
          }
        } catch (error) {
          console.error("‚ùå Error loading game state from database:", error);
        }

        return null;
      }

      // =====================
      // 1. Game Configuration - 100 Levels
      // =====================

      // Level up requirements (same as index.html)
      
     const LEVEL_UP_REQUIREMENTS = [
  6400,
  10400,
  15000,
  20200,
  26000,
  32400,
  39200,
  46600,
  54800,
  63400, // 1-10
  96800,
  110000,
  124000,
  138400,
  153600,
  169800,
  186800,
  204400,
  222800,
  242000, // 11-20
  327400,
  353400,
  380200,
  408000,
  436800,
  466600,
  497400,
  529000,
  561600,
  595200, // 21-30
  779400,
  846800,
  916400,
  988400,
  1062800,
  1139400,
  1218400,
  1299600,
  1383000,
  1468800, // 31-40
  1816400,
  1921800,
  2030200,
  2141000,
  2254600,
  2370800,
  2489800,
  2611400,
  2735800,
  0, // 41-49, 50 l√† ruby
  3420000,
  3762000,
  4104000,
  4446000,
  0, // 51-54, 55 l√† ruby
  4788000,
  5130000,
  5472000,
  5814000,
  0, // 56-59, 60 l√† ruby
  6840000,
  7524000,
  8208000,
  8892000,
  0, // 61-64, 65 l√† ruby
  10260000,
  10944000,
  11628000,
  12312000,
  0, // 66-69, 70 l√† ruby
  12996000,
  14294000,
  15595200,
  16894800,
  0, // 71-74, 75 l√† ruby
  19494000,
  20793600,
  22093200,
  23392800,
  0, // 76-79, 80 l√† ruby
  24692400,
  27161640,
  29630880,
  32100120,
  0, // 81-84, 85 l√† ruby
  37038600,
  39507840,
  41977080,
  44446320,
  0, // 86-89, 90 l√† ruby
  46915560,
  53952896,
  60990228,
  68027564,
  0, // 91-94, 95 l√† ruby
  82102232,
  89139564,
  96016900,
  0, // 96-98, 99 l√† ruby
];


      // Coin per tap by level
      const TAP_COIN_BY_LEVEL = [
        { from: 1, to: 10, value: 24 },
        { from: 11, to: 20, value: 24 },
        { from: 21, to: 30, value: 24 },
        { from: 31, to: 40, value: 24 },
        { from: 41, to: 49, value: 24 },
        { from: 50, to: 60, value: 24 },
        { from: 61, to: 70, value: 24 },
        { from: 71, to: 80, value: 24 },
        { from: 81, to: 90, value: 24 },
        { from: 91, to: 100, value: 24 },
      ];

      // =====================
      // 2. Game State Management - IN-MEMORY ONLY (NO LOCALSTORAGE)
      // =====================

      // In-memory game state (not saved to localStorage to prevent hacking)
      let currentGameState = null;

      function getLevelHP(level) {
        if (level <= 1) return 2400; // Changed to return actual HP points
        let hp = 2400;
        for (let lv = 2; lv <= level; lv++) {
          if (lv <= 30) hp += 11520;
          else if (lv <= 60) hp += 17280;
          else if (lv <= 90) hp += 22800;
          else hp += 28800;
        }
        return hp;
      }

      function getTapCoin(level) {
        if (level <= 1) return 24;
        for (const range of TAP_COIN_BY_LEVEL) {
          if (level >= range.from && level <= range.to) return range.value;
        }
        return 24;
      }

      function getUpgradeMultiplier(level) {
        if (level <= 1) return 1;
        return 1 + (level - 1) * 0.05;
      }

      function getLevelUpRequirement(level) {
        return LEVEL_UP_REQUIREMENTS[level - 1] || 0;
      }

      function getTotalCoinsForLevel(level) {
        if (level <= 1) return 0;
        let total = 0;
        for (let i = 0; i < level - 1; i++) {
          total += LEVEL_UP_REQUIREMENTS[i] || 0;
        }
        return total;
      }

      function canLevelUp(currentLevel, totalCoins) {
        // Calculate total coins needed to reach the NEXT level (currentLevel + 1)
        const totalCoinsNeededForNextLevel = getTotalCoinsForLevel(currentLevel + 1);
        
        console.log(`üîç Level up check details:`);
        console.log(`Current level: ${currentLevel}`);
        console.log(`Ruby coins available: ${totalCoins}`);
        console.log(`Total coins needed for level ${currentLevel + 1}: ${totalCoinsNeededForNextLevel}`);
        console.log(`Can level up: ${totalCoins >= totalCoinsNeededForNextLevel && currentLevel < 100}`);
        
        return (
          totalCoinsNeededForNextLevel > 0 &&
          totalCoins >= totalCoinsNeededForNextLevel &&
          currentLevel < 100
        );
      }

      function loadGameState() {
        console.log("üì± loadGameState() called - memory only, no localStorage");
        console.log("üîç STACK TRACE for loadGameState:");
        console.trace();
        
        // Return current in-memory state if available
        if (window.currentGameState) {
          console.log("üì± Returning current in-memory state:", window.currentGameState);
          return window.currentGameState;
        }
        
        // Return default state for new session
        const defaultLevel = 1;
        const defaultState = {
          level: defaultLevel,
          hp: getLevelHP(defaultLevel),
          coinCount: 0, // Start with 0 coins for new users
          coinEarn: 0,
          smg: 0, // Add SMG field
          lastRecover: Date.now(),
          lastZeroHP: null,
        };
        
        console.log("üì± Returning default state (new user):", defaultState);
        console.log(`üì± Default HP value: ${defaultState.hp}`);
        console.log(`üì± Default coinCount value: ${defaultState.coinCount}`);
        
        // Save default state in memory only
        window.currentGameState = defaultState;
        
        return defaultState;
      }

      // Add flag to prevent syncing during initial load
      let isInitialLoad = true;
      let serverDataLoaded = false;

      function saveGameState(state) {
        console.log("üíæ saveGameState() called with state:", state);
        console.log(`üíæ HP being saved: ${state.hp}`);
        console.log(`üíæ isInitialLoad: ${isInitialLoad}, serverDataLoaded: ${serverDataLoaded}`);
        console.log("üîç STACK TRACE for saveGameState:");
        console.trace();
        
        // Update current game state reference (memory only)
        window.currentGameState = state;
        
        console.log("üíæ State saved to memory only (no localStorage)");

        // CRITICAL FIX: Don't sync to server during initial load or if using default state
        if (telegramUserId && !isInitialLoad && serverDataLoaded) {
          console.log("üåê Initiating server sync for user:", telegramUserId);
          syncGameStateToServer(state);
        } else if (telegramUserId && isInitialLoad) {
          console.log("‚è∏Ô∏è Skipping server sync during initial load to prevent reset");
        } else if (telegramUserId && !serverDataLoaded) {
          console.log("‚è∏Ô∏è Skipping server sync - server data not loaded yet");
        } else {
          console.log("‚ö†Ô∏è No telegramUserId - skipping server sync");
        }
      }

      // Enhanced load function that loads directly from server API only
      async function loadGameStateEnhanced() {
        console.log("üîÑ loadGameStateEnhanced() called - server API only");
        
        let serverState = null;
        
        // Always try to load from server if we have a user ID (including demo users)
        if (telegramUserId) {
          console.log("üåê Loading from server API for user:", telegramUserId);
          
          // Try multiple times with delay to handle network issues
          let attempts = 0;
          const maxAttempts = 3;
          
          while (attempts < maxAttempts && !serverState) {
            attempts++;
            console.log(`üîÑ Attempt ${attempts}/${maxAttempts} to load from server`);
            
            serverState = await loadGameStateFromServer();
            
            if (!serverState && attempts < maxAttempts) {
              console.log(`‚è≥ Waiting 2 seconds before retry...`);
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
          }
          
          if (serverState) {
            console.log("‚úÖ Server state loaded successfully:", serverState);
            
            // Validate server state before using it
            if (serverState.level && serverState.level > 0 && 
                (serverState.coinCount >= 0 || serverState.coinCount === undefined)) {
              console.log("‚úÖ Server state validation passed");
              
              // CRITICAL FIX: Mark that server data was successfully loaded
              serverDataLoaded = true;
              isInitialLoad = false;
              
              window.currentGameState = serverState;
              console.log("üîì Server data loaded - sync enabled for future saves");
              return serverState;
            } else {
              console.log("‚ö†Ô∏è Server state validation failed, checking for existing local state");
            }
          } else {
            console.log("‚ùå Failed to load from server after all attempts");
          }
        } else {
          console.log("‚ö†Ô∏è No user ID available");
        }
        
        // Check if we have existing state in memory before creating default
        if (window.currentGameState && window.currentGameState.level > 1) {
          console.log("üîÑ Using existing in-memory state instead of reset:", window.currentGameState);
          // If we have existing state, allow sync
          serverDataLoaded = true;
          isInitialLoad = false;
          return window.currentGameState;
        }
        
        // Return default state only as last resort
        const defaultLevel = 1;
        const defaultState = {
          level: defaultLevel,
          hp: getLevelHP(defaultLevel),
          coinCount: 0,
          coinEarn: 0,
          smg: 0, // Add SMG field
          lastRecover: Date.now(),
          lastZeroHP: null,
        };
        
        console.log("üì± Returning default state (last resort):", defaultState);
        console.log(`üì± Default HP value: ${defaultState.hp}`);
        console.log("üîí Default state - sync disabled to prevent server reset");
        
        // CRITICAL: Keep flags as they are - don't allow sync of default state
        // serverDataLoaded remains false
        // isInitialLoad remains true
        
        window.currentGameState = defaultState;
        
        return defaultState;
      }

      // =====================
      // 3. UI Update Functions
      // =====================

      function updateUI(state) {
        const maxHP = getLevelHP(state.level);
        const hpPercentage = Math.max(
          0,
          Math.min(100, (state.hp / maxHP) * 100)
        );

        // Update HP display - CHANGED: Show percentage instead of actual numbers
        document.getElementById(
          "hp-display"
        ).textContent = `${Math.round(hpPercentage)}/100`;
        document.getElementById("hp-bar").style.width = `${hpPercentage}%`;

        // Update HP progress icon position
        const hpProgressIcon = document.querySelector(
          ".hp-progress-container .progress-icon"
        );
        if (hpProgressIcon) {
          hpProgressIcon.style.left = `${hpPercentage}%`;
        }

        // Update coin displays - BOTH show the same ruby count
        // Ruby (coin-count) shows the ruby count
        // Money (coin-earn) also shows the ruby count for consistency
        const coinCountElement = document.getElementById("coin-count");
        const coinEarnElement = document.getElementById("coin-earn");
        
        // Ensure both elements display the current ruby count
        const displayValue = state.coinCount || 0; // Fallback to 0 if undefined
        
        if (coinCountElement) {
          coinCountElement.textContent = displayValue;
        }
        
        if (coinEarnElement) {
          coinEarnElement.textContent = displayValue;
        }

        // Update level displays
        document.getElementById(
          "hp-level-display"
        ).textContent = `Lv ${state.level}`;
        document.getElementById(
          "lp-level-display"
        ).textContent = `Lv ${state.level}`;

        // Calculate level progress based on current coins vs level up requirement
        const totalCoinsNeededForNextLevel = getTotalCoinsForLevel(state.level + 1);
        let levelProgress = 0;

        if (totalCoinsNeededForNextLevel > 0) {
          // Calculate progress based on current coins vs requirement for NEXT level
          const totalCoinsNeededForCurrentLevel = getTotalCoinsForLevel(state.level);
          const totalCoinsAvailable = state.coinCount; // Only use coinCount now
          const coinsTowardsNextLevel = totalCoinsAvailable - totalCoinsNeededForCurrentLevel;
          const coinsNeededForNextLevel = totalCoinsNeededForNextLevel - totalCoinsNeededForCurrentLevel;

          levelProgress = Math.min(
            100,
            Math.max(
              0,
              (coinsTowardsNextLevel / coinsNeededForNextLevel) * 100
            )
          );
          
          console.log(`üìä Level progress calculation:`);
          console.log(`Total coins available: ${totalCoinsAvailable}`);
          console.log(`Coins needed for current level ${state.level}: ${totalCoinsNeededForCurrentLevel}`);
          console.log(`Coins needed for next level ${state.level + 1}: ${totalCoinsNeededForNextLevel}`);
          console.log(`Coins towards next level: ${coinsTowardsNextLevel}`);
          console.log(`Coins needed for next level: ${coinsNeededForNextLevel}`);
          console.log(`Level progress: ${levelProgress}%`);
        } else {
          // If no requirement (max level or special level), show 100%
          levelProgress = 100;
        }

        // Update level progress bars - fix the IDs
        const hpLevelBar = document.getElementById("hp-level-bar");
        const lpLevelBar = document.getElementById("lp-level-bar");

        if (hpLevelBar) {
          hpLevelBar.style.width = `${levelProgress}%`;
        }
        if (lpLevelBar) {
          lpLevelBar.style.width = `${levelProgress}%`;
        }

        // Update level progress icons
        const hpLevelIcon = document.querySelector(
          ".hp-level-progress-container .level-progress-icon"
        );
        const lpLevelIcon = document.querySelector(
          ".lp-level-progress-container .level-progress-icon"
        );

        if (hpLevelIcon) {
          hpLevelIcon.style.left = `${levelProgress}%`;
        }
        if (lpLevelIcon) {
          lpLevelIcon.style.left = `${levelProgress}%`;
        }
        
        // Update user ID display
        const userIdElement = document.querySelector(".user-id");
        console.log("üîç Debug user display:", {
          userIdElement: !!userIdElement,
          telegramUserData: telegramUserData,
          telegramUserId: telegramUserId
        });
        
        if (userIdElement && telegramUserData) {
          // Priority: username > first_name > user ID
          let displayName = telegramUserData.username
            ? `@${telegramUserData.username}`
            : telegramUserData.first_name
            ? telegramUserData.first_name
            : telegramUserId || "Unknown";

          console.log("üéØ Display name chosen:", displayName);
          userIdElement.textContent = displayName;
          userIdElement.classList.add("dashed-text");
        } else if (userIdElement && telegramUserId) {
          // Fallback to user ID if no user data available
          console.log("‚ö†Ô∏è Fallback to user ID:", telegramUserId);
          userIdElement.textContent = telegramUserId;
          userIdElement.classList.add("dashed-text");
        }

        // Update avatar display
        updateAvatarDisplay();
      }

      // Function to update avatar display
      function updateAvatarDisplay() {
        const avatarElement = document.querySelector(".w-8.h-8");
        if (avatarElement && telegramUserData) {
          let avatarLetter = "U"; // Default

          if (telegramUserData.first_name) {
            avatarLetter = telegramUserData.first_name.charAt(0).toUpperCase();
          } else if (telegramUserData.username) {
            avatarLetter = telegramUserData.username.charAt(0).toUpperCase();
          }

          avatarElement.textContent = avatarLetter;
        }
      }

      // =====================
      // 4. Flying Coin Animation
      // =====================

      function createFlyingCoin(startX, startY, targetElement) {
        const coin = document.createElement("div");
        coin.className = "flying-coin";
        coin.style.left = startX + "px";
        coin.style.top = startY + "px";

        const targetRect = targetElement.getBoundingClientRect();
        const targetX = targetRect.left + targetRect.width / 2;
        const targetY = targetRect.top + targetRect.height / 2;

        const deltaX = targetX - startX;
        const deltaY = targetY - startY;

        coin.style.setProperty("--tx", deltaX + "px");
        coin.style.setProperty("--ty", deltaY + "px");

        document.body.appendChild(coin);

        setTimeout(() => {
          if (coin.parentNode) {
            coin.parentNode.removeChild(coin);
          }
        }, 2500);
      }

      function createFlyingScoreText(startX, startY, score, isSpecial = false) {
        const scoreText = document.createElement("div");
        scoreText.className = isSpecial ? "flying-score-text special" : "flying-score-text";
        scoreText.textContent = `+${score}`;
        scoreText.style.left = startX + "px";
        scoreText.style.top = startY + "px";

        // Add some random horizontal offset for variety
        const randomOffset = (Math.random() - 0.5) * 60; // -30px to +30px
        scoreText.style.transform = `translate(calc(-50% + ${randomOffset}px), -50%)`;

        document.body.appendChild(scoreText);

        setTimeout(() => {
          if (scoreText.parentNode) {
            scoreText.parentNode.removeChild(scoreText);
          }
        }, 1500);
      }

      // =====================
      // 5. Character Animation Functions
      // =====================

      function createSparkles() {
        const sparkleContainer = document.createElement("div");
        sparkleContainer.style.cssText = `
          position: absolute;
          bottom: -50px;
          left: 50%;
          transform: translateX(-50%);
          width: 600px;
          height: 600px;
          pointer-events: none;
          z-index: 6;
        `;

        // Create multiple sparkle particles
        for (let i = 0; i < 12; i++) {
          const sparkle = document.createElement("div");
          const size = Math.random() * 8 + 4;
          const delay = Math.random() * 0.3;
          const duration = Math.random() * 0.8 + 0.6;
          const x = (Math.random() - 0.5) * 400;
          const y = (Math.random() - 0.5) * 400;

          sparkle.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            background: radial-gradient(circle, #ffffff 0%, #ffeb3b 50%, transparent 100%);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: sparkleFloat ${duration}s ease-out ${delay}s forwards;
            opacity: 0;
          `;

          sparkle.style.setProperty("--x", x + "px");
          sparkle.style.setProperty("--y", y + "px");

          sparkleContainer.appendChild(sparkle);
        }

        // Add sparkle animation
        const style = document.createElement("style");
        style.textContent = `
          @keyframes sparkleFloat {
            0% {
              transform: translate(-50%, -50%) scale(0) rotate(0deg);
              opacity: 0;
            }
            20% {
              transform: translate(calc(-50% + var(--x) * 0.2), calc(-50% + var(--y) * 0.2)) scale(1) rotate(90deg);
              opacity: 1;
            }
            80% {
              transform: translate(calc(-50% + var(--x) * 0.8), calc(-50% + var(--y) * 0.8)) scale(0.8) rotate(270deg);
              opacity: 0.8;
            }
            100% {
              transform: translate(calc(-50% + var(--x)), calc(-50% + var(--y))) scale(0) rotate(360deg);
              opacity: 0;
            }
          }
        `;
        document.head.appendChild(style);

        return { container: sparkleContainer, style };
      }

      function triggerCharacterPress(isSpecial = false) {
        const characterContainer = document.querySelector(
          ".character-container"
        );
        const soleElement = document.getElementById("sole");
        const lightEffect = document.getElementById("light-effect");

        // Apply enhanced character effects
        if (isSpecial) {
          // 3-finger tap effects
          triggerEnhancedCharacterEffects('super');
        } else {
          // Normal tap effects
          triggerEnhancedCharacterEffects('normal');
        }

        characterContainer.classList.add("pressed");
        soleElement.classList.add("pressed");

        // Show light effect (without pressed movement)
        if (lightEffect) {
          lightEffect.classList.add("show");
          if (isSpecial) {
            lightEffect.classList.add("special");
          }
        }

        // Create sparkles effect
        const sparkleData = createSparkles();
        const soleContainer = soleElement.parentElement;
        soleContainer.appendChild(sparkleData.container);

        setTimeout(
          () => {
            characterContainer.classList.remove("pressed");
            soleElement.classList.remove("pressed");

            // Hide light effect
            if (lightEffect) {
              lightEffect.classList.remove("show");
              if (isSpecial) {
                lightEffect.classList.remove("special");
              }
            }

            // Clean up sparkles
            setTimeout(() => {
              if (sparkleData.container.parentNode) {
                sparkleData.container.parentNode.removeChild(
                  sparkleData.container
                );
              }
              if (sparkleData.style.parentNode) {
                sparkleData.style.parentNode.removeChild(sparkleData.style);
              }
            }, 1000);
          },
          isSpecial ? 300 : 200
        );
      }

      // =====================
      // Enhanced Character Effects Functions
      // =====================

      function triggerEnhancedCharacterEffects(type = 'normal') {
        const characterContainer = document.querySelector(".character-container");
        
        if (!characterContainer) return;

        // Clear any existing animation classes
        characterContainer.classList.remove('bounce', 'shake', 'glow', 'super-glow');
        
        // Apply effects based on type
        if (type === 'super') {
          // 3-finger tap effects
          characterContainer.classList.add('super-glow');
          createParticleEffect(true); // Golden particles
          createEnergyWave(true); // Golden energy wave
          
          // Add bounce after a short delay
          setTimeout(() => {
            characterContainer.classList.add('bounce');
          }, 100);
          
        } else if (type === 'normal') {
          // Normal tap effects
          const effects = ['bounce', 'glow', 'shake'];
          const randomEffect = effects[Math.floor(Math.random() * effects.length)];
          
          characterContainer.classList.add(randomEffect);
          createParticleEffect(false); // Normal particles
          createEnergyWave(false); // Normal energy wave
          
          // 20% chance for heart effect on normal taps
          if (Math.random() < 0.2) {
          }
        }

        // Clean up animation classes after animations complete
        setTimeout(() => {
          characterContainer.classList.remove('bounce', 'shake', 'glow', 'super-glow');
        }, 1500);
      }

      function createParticleEffect(isGolden = false) {
        const characterContainer = document.querySelector(".character-container");
        if (!characterContainer) return;

        // Create particle container
        const particleContainer = document.createElement('div');
        particleContainer.className = 'character-particles';
        
        // Create multiple particles
        const particleCount = isGolden ? 12 : 8;
        
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = isGolden ? 'particle golden' : 'particle';
          
          // Random direction and distance
          const angle = (360 / particleCount) * i + Math.random() * 30 - 15;
          const distance = 40 + Math.random() * 30;
          const dx = Math.cos(angle * Math.PI / 180) * distance;
          const dy = Math.sin(angle * Math.PI / 180) * distance;
          
          particle.style.setProperty('--dx', dx + 'px');
          particle.style.setProperty('--dy', dy + 'px');
          
          // Random position within container
          particle.style.left = (50 + Math.random() * 20 - 10) + '%';
          particle.style.top = (50 + Math.random() * 20 - 10) + '%';
          
          particleContainer.appendChild(particle);
        }
        
        characterContainer.appendChild(particleContainer);
        
        // Clean up after animation
        setTimeout(() => {
          if (particleContainer.parentNode) {
            particleContainer.parentNode.removeChild(particleContainer);
          }
        }, isGolden ? 2000 : 1500);
      }

      function createEnergyWave(isGolden = false) {
        const characterContainer = document.querySelector(".character-container");
        if (!characterContainer) return;

        const energyWave = document.createElement('div');
        energyWave.className = isGolden ? 'energy-wave golden' : 'energy-wave';
        
        characterContainer.appendChild(energyWave);
        
        // Clean up after animation
        setTimeout(() => {
          if (energyWave.parentNode) {
            energyWave.parentNode.removeChild(energyWave);
          }
        }, isGolden ? 1000 : 800);
      }

      
      // Enhanced screen shake effect for special moments
      function triggerScreenShake() {
        const gameContainer = document.querySelector('.md\\:w-\\[375px\\]') || document.querySelector("[class*='w-[375px]']") || document.querySelector('.gradient-bg');
        if (!gameContainer) return;

        gameContainer.style.animation = 'screenShake 0.5s ease-in-out';
        
        // Add screen shake keyframes if not exists
        if (!document.querySelector('#screen-shake-style')) {
          const style = document.createElement('style');
          style.id = 'screen-shake-style';
          style.textContent = `
            @keyframes screenShake {
              0%, 100% { transform: translateX(0); }
              10% { transform: translateX(-2px) translateY(-1px); }
              20% { transform: translateX(2px) translateY(1px); }
              30% { transform: translateX(-2px) translateY(-1px); }
              40% { transform: translateX(2px) translateY(1px); }
              50% { transform: translateX(-1px) translateY(-1px); }
              60% { transform: translateX(1px) translateY(1px); }
              70% { transform: translateX(-1px) translateY(-1px); }
              80% { transform: translateX(1px) translateY(1px); }
              90% { transform: translateX(-0.5px); }
            }
          `;
          document.head.appendChild(style);
        }
        
        // Clean up animation
        setTimeout(() => {
          gameContainer.style.animation = '';
        }, 500);
      }

      // =====================
      // 6. Main Tap Function
      // =====================

      function tap(event, multiplier = 1) {
        // Generate unique ID for this tap call
        const tapId = Date.now() + Math.random().toString(36).substr(2, 9);
        console.log("üéØ TAP FUNCTION CALLED - ID:", tapId);
        console.log("Tap function called!", event, multiplier);
        let state = loadGameState();
        console.log("Current state:", state);

        if (state.hp <= 0) {
          console.log("Cannot tap - HP is 0");
          return;
        }

        // Check for 3-finger tap on touch devices - IMPROVED DETECTION
        let finalMultiplier = multiplier;
        let hpMultiplier = 1; // Separate multiplier for HP loss
        let is3FingerTap = false;

        // Enhanced 3-finger detection with multiple checks
        if (event && event.touches) {
          const touchCount = event.touches.length;
          console.log("Touch count detected:", touchCount);

          if (touchCount >= 3) {
            // Don't modify finalMultiplier here - handle it in coin calculation
            hpMultiplier = 3; // 3x HP loss for 3-finger tap (12 HP)
            is3FingerTap = true;
            console.log(
              "üî• 3-FINGER TAP CONFIRMED! Touch count:",
              touchCount,
              "HP multiplier:",
              hpMultiplier
            );

            // Add special visual feedback for 3-finger tap
            triggerSpecial3FingerEffect();
          } else {
            console.log("Normal tap detected with", touchCount, "finger(s)");
          }
        } else if (event && !event.touches) {
          console.log("Mouse click detected (no touch data)");
        } else {
          console.log("No event data available");
        }

        // PROTECTION: Check if this is a duplicate HP change - ENHANCED
        const currentTime = Date.now();
        const oldHP = state.hp; // Move this line here - BEFORE it's used

        // For 3-finger taps, use stricter duplicate detection
        if (is3FingerTap) {
          // Check multiple conditions for duplicate detection
          const timeSinceLastHPChange = currentTime - lastHPChangeTime;
          const isSameHP = lastHPValue === oldHP;
          const tooSoon = timeSinceLastHPChange < 1500; // Increased from 1000ms to 1500ms

          console.log("üõ°Ô∏è 3-FINGER TAP DUPLICATE CHECK:");
          console.log("Time since last HP change:", timeSinceLastHPChange);
          console.log(
            "Is same HP value:",
            isSameHP,
            "(",
            lastHPValue,
            "vs",
            oldHP,
            ")"
          );
          console.log("Too soon?", tooSoon);

          if (tooSoon && isSameHP) {
            console.log("üõ°Ô∏è DUPLICATE 3-FINGER TAP DETECTED - BLOCKING");
            return; // Exit early to prevent duplicate processing
          }
        }

        // Update tracking variables BEFORE processing
        lastHPChangeTime = currentTime;
        lastHPValue = oldHP;

        console.log("‚úÖ TAP PROCESSING APPROVED - ID:", tapId);

        // Create flying coin effect - targeting ruby display directly
        if (event) {
          // Get the ruby display element (coin-count)
          const rubyDisplay = document.getElementById("coin-earn");

          if (rubyDisplay) {
            console.log("üéØ Flying coins targeting: Ruby display");

            // Number of coins based on tap type
            const baseCoins = is3FingerTap ? 3 : 1;

            // Create coins flying to the ruby display
            for (let i = 0; i < baseCoins; i++) {
              setTimeout(() => {
                createFlyingCoin(
                  event.clientX ||
                    event.touches?.[0]?.clientX ||
                    window.innerWidth / 2,
                  event.clientY ||
                    event.touches?.[0]?.clientY ||
                    window.innerHeight / 2,
                  rubyDisplay
                );
              }, i * 100); // Stagger coins with 100ms delay
            }
          }

          // Trigger character press animation
          if (!is3FingerTap) {
            triggerCharacterPress();
          }
        }

        // Decrease HP with proper calculation
        const baseHPLoss = getHPLoss(state.level); // NEW: Get HP loss based on level
        const hpLoss = Math.round(baseHPLoss * hpMultiplier); // Should be baseHPLoss for normal, baseHPLoss*3 for 3-finger

        // Validate HP loss calculation
        const expectedHPLoss = is3FingerTap ? baseHPLoss * 3 : baseHPLoss; // Updated to use baseHPLoss

        // FORCE CORRECT HP LOSS - especially for 3-finger taps
        let actualHPLoss;
        if (is3FingerTap) {
          // Force exactly 3x HP loss for 3-finger tap
          actualHPLoss = baseHPLoss * 3;
          console.log("üîí FORCING 3-finger tap HP loss to exactly", actualHPLoss, "(3x", baseHPLoss, ")");
        } else {
          // Use calculated value for normal taps
          actualHPLoss = hpLoss;
        }

        if (hpLoss !== expectedHPLoss) {
          console.error(
            "HP loss calculation error! Expected:",
            expectedHPLoss,
            "Got:",
            hpLoss,
            "Using forced value:",
            actualHPLoss
          );
        }

        // Apply the HP loss
        state.hp -= actualHPLoss;
        console.log(
          "HP changed from",
          oldHP,
          "to",
          state.hp,
          "(-" + actualHPLoss + " HP)",
          is3FingerTap ? "(3-finger tap - FORCED)" : "(normal tap)"
        );

        // Calculate coins with proper multiplier - FIXED: Always 24 coins per tap
        let tapCoin;
        const baseCoin = 24; // FIXED: Always 24 coins per tap regardless of level

        console.log("üîß USING FIXED COIN LOGIC - baseCoin is hardcoded to 24");
        console.log("=== COIN CALCULATION DEBUG ===");
        console.log("Level:", state.level);
        console.log("baseHPLoss (HP loss for this level):", baseHPLoss);
        console.log("baseCoin (FIXED to 24):", baseCoin);
        console.log("upgradeMultiplier: REMOVED - always 1");
        console.log("is3FingerTap:", is3FingerTap);
        console.log("finalMultiplier:", finalMultiplier);

        if (finalMultiplier === 0.25) {
          // Auto-earn case: 24 / 4 = 6 coins
          tapCoin = Math.floor(baseCoin / 4);
          console.log("Auto-earn calculation:", baseCoin, "/ 4 =", tapCoin);
        } else if (is3FingerTap) {
          // 3-finger tap: exactly 3x the base coin = 72 coins
          tapCoin = Math.floor(baseCoin * 3);
          console.log(
            "3-finger tap coin calculation:",
            baseCoin,
            "* 3 =",
            tapCoin
          );
        } else {
          // Normal tap: exactly 24 coins
          tapCoin = baseCoin;
          console.log(
            "Normal tap coin calculation:",
            baseCoin,
            "=",
            tapCoin
          );
        }

        console.log("Final tapCoin value:", tapCoin);
        console.log("=== END COIN CALCULATION ===");

        // Create flying score text effect
        if (event && tapCoin > 0) {
          const tapX = event.clientX || event.touches?.[0]?.clientX || window.innerWidth / 2;
          const tapY = event.clientY || event.touches?.[0]?.clientY || window.innerHeight / 2;
          
          // Show flying score text with special effect for 3-finger tap
          createFlyingScoreText(tapX, tapY, tapCoin, is3FingerTap);
        }

        // Play coin sound effect
        playCoinSound();

        // Add coins directly to coinCount (ruby count)
        state.coinCount += tapCoin;
        
        // Log tap summary
        console.log("=== TAP SUMMARY ===");
        console.log("Tap type:", is3FingerTap ? "3-FINGER TAP" : "NORMAL TAP");
        console.log("Base coin per tap:", getTapCoin(state.level));
        console.log("Upgrade multiplier: REMOVED - always 1");
        console.log("Final coin earned:", tapCoin);
        console.log("HP lost:", actualHPLoss);
        console.log("Total ruby count:", state.coinCount);
        console.log("==================");

        // Handle HP reaching 0
        if (state.hp <= 0) {
          state.hp = 0;
          state.lastRecover = Date.now();
          state.lastZeroHP = Date.now();

          // Trigger special "faint" effects when HP reaches 0
          triggerHPZeroEffects();

          saveGameState(state);
          updateUI(state);

          // Check for level up after delay
          setTimeout(() => {
            let currentState = loadGameState();
            if (canLevelUp(currentState.level, currentState.coinCount)) {
              const oldLevel = currentState.level;
              currentState.level++;
              console.log(`üéâ LEVEL UP after HP=0! ${oldLevel} ‚Üí ${currentState.level} (Total ruby: ${currentState.coinCount})`);
              
              if (currentState.hp > 0) {
                currentState.hp = getLevelHP(currentState.level);
              }
              saveGameState(currentState);
              updateUI(currentState);
              showLevelUpPopup(currentState.level);
            }
          }, 500);

          return;
        }

        // Check for level up (when HP > 0)
        console.log(`üîç Level up check: Level ${state.level}, Total ruby: ${state.coinCount}`);
        
        if (canLevelUp(state.level, state.coinCount)) {
          const oldLevel = state.level;
          state.level++;
          console.log(`üéâ LEVEL UP! ${oldLevel} ‚Üí ${state.level} (Total ruby: ${state.coinCount})`);
          
          if (state.hp > 0) {
            // Don't reset HP when leveling up - preserve remaining HP
          }
          showLevelUpPopup(state.level);
        }

        saveGameState(state);
        updateUI(state);
        console.log("Tap completed, state saved - ID:", tapId);
      }

      // =====================
      // 6.1. Special 3-Finger Effect
      // =====================

      function triggerSpecial3FingerEffect() {
        // Trigger screen shake for dramatic effect
        triggerScreenShake();
        
        // Add special glow effect to character
        const character = document.getElementById("younghee");
        const sole = document.getElementById("sole");

        if (character && sole) {
          character.style.filter =
            "drop-shadow(0 0 20px #FFD700) brightness(1.3)";
          sole.style.filter = "drop-shadow(0 0 15px #FFD700) brightness(1.2)";

          // Remove effect after animation
          setTimeout(() => {
            character.style.filter = "";
            sole.style.filter = "";
          }, 500);
        }

        // Show 3x multiplier text
        show3xMultiplierText();

        // Trigger special character press with light effect
        triggerCharacterPress(true);
        
        // Add extra dramatic effects
        setTimeout(() => {
          createMultipleEnergyWaves();
        }, 200);
      }

      // Create multiple energy waves for extra dramatic effect
      function createMultipleEnergyWaves() {
        const characterContainer = document.querySelector(".character-container");
        if (!characterContainer) return;

        // Create 3 energy waves with different delays
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            const energyWave = document.createElement('div');
            energyWave.className = 'energy-wave golden';
            energyWave.style.animationDelay = `${i * 0.1}s`;
            
            characterContainer.appendChild(energyWave);
            
            // Clean up after animation
            setTimeout(() => {
              if (energyWave.parentNode) {
                energyWave.parentNode.removeChild(energyWave);
              }
            }, 1200);
          }, i * 150);
        }
      }

      function show3xMultiplierText() {
        // Create floating 3x text
        const multiplierText = document.createElement("div");
        multiplierText.textContent = "üî• 3X COINS! üî•";
        multiplierText.style.cssText = `
          position: fixed;
          top: 30%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 28px;
          font-weight: bold;
          color: #FFD700;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px #FFD700;
          z-index: 9999;
          pointer-events: none;
          animation: bounce3x 1.5s ease-out forwards;
          font-family: 'Gugi', sans-serif;
          border: 2px solid #FFD700;
          background: rgba(0,0,0,0.8);
          padding: 10px 20px;
          border-radius: 15px;
        `;

        // Add bounce animation
        const style = document.createElement("style");
        style.textContent = `
          @keyframes bounce3x {
            0% { 
              transform: translate(-50%, -50%) scale(0.3) rotate(-10deg); 
              opacity: 0; 
            }
            30% { 
              transform: translate(-50%, -50%) scale(1.4) rotate(5deg); 
              opacity: 1; 
            }
            60% { 
              transform: translate(-50%, -50%) scale(0.9) rotate(-2deg); 
              opacity: 1; 
            }
            80% { 
              transform: translate(-50%, -50%) scale(1.1) rotate(1deg); 
              opacity: 1; 
            }
            100% { 
              transform: translate(-50%, -50%) scale(1) translateY(-50px) rotate(0deg); 
              opacity: 0; 
            }
          }
        `;
        document.head.appendChild(style);
        document.body.appendChild(multiplierText);

        // Add screen flash effect
        const flashOverlay = document.createElement("div");
        flashOverlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
          z-index: 9998;
          pointer-events: none;
          animation: flashEffect 0.5s ease-out forwards;
        `;

        const flashStyle = document.createElement("style");
        flashStyle.textContent = `
          @keyframes flashEffect {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
          }
        `;
        document.head.appendChild(flashStyle);
        document.body.appendChild(flashOverlay);

        // Remove after animation
        setTimeout(() => {
          if (multiplierText.parentNode) {
            multiplierText.parentNode.removeChild(multiplierText);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
          if (flashOverlay.parentNode) {
            flashOverlay.parentNode.removeChild(flashOverlay);
          }
          if (flashStyle.parentNode) {
            flashStyle.parentNode.removeChild(flashStyle);
          }
        }, 1500);
      }

      // =====================
      // 7. HP Recovery Function
      // =====================

      async function recoverHP() {
        let state = loadGameState();

        // Only 3-minute 2% HP recovery logic
        const currentTime = Date.now();
        if (!state.lastRecover) {
          state.lastRecover = currentTime;
        }

        const timeSinceLastRecover = currentTime - state.lastRecover;
        if (timeSinceLastRecover >= 3 * 60 * 1000) {
          // 3 minutes
          const maxHP = getLevelHP(state.level);
          const recoveryAmount = Math.floor(maxHP * 0.02); // 2% of max HP

          // Recover 2% regardless of current HP amount, but don't exceed max HP
          if (state.hp < maxHP) {
            const oldHP = state.hp;
            state.hp = Math.min(maxHP, state.hp + recoveryAmount);
            state.lastRecover = currentTime;

            // Save locally first
            saveGameState(state);
            updateUI(state);

            // Sync HP recovery with server
            try {
              const response = await fetch(`/api/user/${telegramUserId}`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  hp: state.hp,
                  lastRecover: state.lastRecover,
                }),
              });

              if (response.ok) {
                const result = await response.json();
                console.log(
                  `üíö HP Recovery synced: ${oldHP} ‚Üí ${state.hp} (+${recoveryAmount})`
                );

                // Show recovery notification
                showFloatingText(`+${recoveryAmount} HP`, "#4CAF50");
              } else {
                console.warn("‚ö†Ô∏è Failed to sync HP recovery with server");
              }
            } catch (error) {
              console.warn("‚ö†Ô∏è Error syncing HP recovery:", error);
            }
          }
        }
      }

      // =====================
      // 8. Level Up Popup Functions
      // =====================

      function showLevelUpPopup(newLevel) {
        const popup = document.getElementById("level-up-popup");
        const titleElement = popup.querySelector(".level-up-title");

        // Play level up sound effect
        playLevelUpSound();

        if (titleElement) {
          titleElement.textContent = `Level ${newLevel}!`;
        }

        // Trigger celebration effects on character
        triggerLevelUpCelebration();

        popup.style.display = "flex";
        popup.classList.add("show");
      }

      // Special celebration effects for level up
      function triggerLevelUpCelebration() {
        const characterContainer = document.querySelector(".character-container");
        if (!characterContainer) return;

        // Multiple celebration effects
        triggerEnhancedCharacterEffects('super');
        
        // Screen shake for excitement
        setTimeout(() => {
          triggerScreenShake();
        }, 300);
        
        // Multiple heart effects
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
          }, i * 200);
        }
        
        // Continuous particle effects
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            createParticleEffect(true); // Golden particles
          }, i * 400);
        }
        
        // Energy wave burst
        setTimeout(() => {
          createMultipleEnergyWaves();
        }, 500);
      }

      function closeLevelUpPopup() {
        const popup = document.getElementById("level-up-popup");
        popup.classList.remove("show");
        setTimeout(() => {
          popup.style.display = "none";
        }, 300);
      }

      // =====================
      // 9. Auto Earn Function - Now handled by auto-earn-shared.js
      // =====================

      // =====================
      // 10. Event Listeners
      // =====================

      // Add debounce mechanism to prevent multiple taps
      let lastTapTime = 0;
      const TAP_DEBOUNCE_MS = 50; // Reduced from 100ms to 50ms for better responsiveness

      // Separate tracking for multi-touch to avoid debounce interference
      let lastMultiTouchTime = 0;
      const MULTI_TOUCH_DEBOUNCE_MS = 600; // Increased from 500ms to 800ms to prevent duplicates

      // Add flag to track if 3-finger tap is being processed
      let isProcessing3FingerTap = false;

      // Track last HP change to prevent duplicates - ENHANCED
      let lastHPChangeTime = 0;
      let lastHPValue = 0;
      let lastTapProcessTime = 0; // New: track when tap was last processed

      function debouncedTap(event, multiplier = 1) {
        const currentTime = Date.now();

        // ENHANCED DUPLICATE PROTECTION
        if (currentTime - lastTapProcessTime < 100) {
          console.log("‚ùå TAP IGNORED - Too soon after last tap processing");
          return;
        }

        // Check if this is a multi-touch event (3+ fingers)
        const isMultiTouch =
          event && event.touches && event.touches.length >= 3;

        console.log("=== DEBOUNCED TAP CALLED ===");
        console.log("Current time:", currentTime);
        console.log("Is multi-touch:", isMultiTouch);
        console.log("Touch count:", event?.touches?.length || "N/A");

        if (isMultiTouch) {
          // Use separate debounce for multi-touch
          console.log("Last multi-touch time:", lastMultiTouchTime);
          console.log(
            "Time since last multi-touch:",
            currentTime - lastMultiTouchTime
          );
          console.log("Is processing 3-finger tap:", isProcessing3FingerTap);

          if (isProcessing3FingerTap) {
            console.log(
              "‚ùå Multi-touch tap IGNORED - already processing 3-finger tap"
            );
            return;
          }

          if (currentTime - lastMultiTouchTime < MULTI_TOUCH_DEBOUNCE_MS) {
            console.log("‚ùå Multi-touch tap IGNORED due to debounce");
            return;
          }

          // Set processing flag IMMEDIATELY
          isProcessing3FingerTap = true;
          lastMultiTouchTime = currentTime;
          lastTapProcessTime = currentTime; // Update tap process time
          console.log(
            "‚úÖ Multi-touch tap ACCEPTED, updating lastMultiTouchTime to:",
            lastMultiTouchTime
          );
          console.log(
            "Multi-touch detected with",
            event.touches.length,
            "fingers"
          );

          // Clear processing flag after a longer delay
          setTimeout(() => {
            isProcessing3FingerTap = false;
            console.log("üîÑ 3-finger tap processing flag cleared");
          }, 600); // Increased from 300ms to 600ms
        } else {
          // Use normal debounce for single touch
          console.log("Last single tap time:", lastTapTime);
          console.log("Time since last single tap:", currentTime - lastTapTime);

          if (currentTime - lastTapTime < TAP_DEBOUNCE_MS) {
            console.log("‚ùå Single tap IGNORED due to debounce");
            return;
          }
          lastTapTime = currentTime;
          lastTapProcessTime = currentTime; // Update tap process time
          console.log(
            "‚úÖ Single tap ACCEPTED, updating lastTapTime to:",
            lastTapTime
          );
        }

        console.log("üéØ Calling tap function...");
        tap(event, multiplier);
      }

      // Initialize game state on page load
      document.addEventListener('DOMContentLoaded', async function() {
        console.log("üöÄ Page loaded, initializing game...");
        
        // Set initial flags to prevent premature syncing
        isInitialLoad = true;
        serverDataLoaded = false;
        console.log("üîí Initial load flags set - sync disabled during load");
        
        // Get user ID first
        telegramUserId = getTelegramUserId();
        console.log("üë§ User ID:", telegramUserId);
        
        // Load game state using enhanced function
        try {
          const gameState = await loadGameStateEnhanced();
          console.log("‚úÖ Game state loaded:", gameState);
          
          // Update UI with loaded state
          updateUI(gameState);
          updateAvatarDisplay();
          
          console.log("üéÆ Game initialization complete");
          
        } catch (error) {
          console.error("‚ùå Error during game initialization:", error);
          
          // Fallback to default state if initialization fails
          const defaultState = {
            level: 1,
            hp: getLevelHP(1),
            coinCount: 0,
            coinEarn: 0,
            smg: 0,
            lastRecover: Date.now(),
            lastZeroHP: null,
          };
          
          window.currentGameState = defaultState;
          updateUI(defaultState);
          updateAvatarDisplay();
          
          console.log("üîí Fallback state loaded - sync disabled to prevent server reset");
        }
        
        // Initialize bottom navigation
        initializeBottomNavigation();
        
        // Add tap event listeners for the main container only
        const mainContainer = document.querySelector(".md\\:w-\\[375px\\]") || document.querySelector("[class*='w-[375px]']") || document.querySelector(".gradient-bg");
        if (mainContainer) {
          // Handle click events (for desktop/mouse)
          mainContainer.addEventListener("click", function (event) {
            // Don't tap if clicking on buttons or UI elements
            if (
              event.target.closest("#auto-earn-button") ||
              event.target.closest(".level-up-popup") ||
              event.target.closest("button") ||
              event.target.closest("#bottom-navigation") ||
              event.target.closest(".nav-item")
            ) {
              return;
            }

            event.preventDefault();
            event.stopPropagation();
            debouncedTap(event);
          });

          // Handle touch events (for mobile) - IMPROVED FOR MULTI-TOUCH
          mainContainer.addEventListener("touchstart", function (event) {
            // Don't tap if touching buttons or UI elements
            if (
              event.target.closest("#auto-earn-button") ||
              event.target.closest(".level-up-popup") ||
              event.target.closest("button") ||
              event.target.closest("#bottom-navigation") ||
              event.target.closest(".nav-item")
            ) {
              return;
            }

            // Log touch information for debugging
            console.log("Touch detected:", event.touches.length, "fingers");

            // For multi-touch, don't prevent default immediately to allow proper detection
            if (event.touches.length >= 3) {
              console.log("3+ finger touch detected, processing...");
              // Allow some time for touch registration before preventing default
              setTimeout(() => {
                event.preventDefault();
              }, 10);
            } else {
              event.preventDefault();
            }

            event.stopPropagation();
            debouncedTap(event);
          });

          // Add touchend handler to catch any missed multi-touch events
          mainContainer.addEventListener("touchend", function (event) {
            // Check if we had multiple touches that just ended
            if (event.changedTouches && event.changedTouches.length >= 2) {
              console.log(
                "Multi-touch ended, checking for missed 3-finger tap"
              );
              // This might catch cases where touchstart missed the multi-touch
            }
            event.preventDefault();
          });

          // Reduce interference from touchmove
          mainContainer.addEventListener("touchmove", function (event) {
            // Only prevent default for single touch to avoid interfering with multi-touch detection
            if (event.touches.length === 1) {
              event.preventDefault();
            }
          });
        }

        // Initialize auto earn functionality
        initializeAutoEarn();

        // HP recovery interval
        setInterval(recoverHP, 60 * 1000); // Every minute

        console.log("üéÆ Game Interface Setup Complete");
      });

      // Close popup when clicking outside
      document
        .getElementById("level-up-popup")
        .addEventListener("click", function (event) {
          if (event.target === this) {
            closeLevelUpPopup();
          }
        });

      // =====================
      // 6. Visual Effects Functions
      // =====================

      function showFloatingText(text, color = "#FFD93D", x = null, y = null) {
        const floatingText = document.createElement("div");
        floatingText.textContent = text;
        floatingText.style.cssText = `
          position: fixed;
          left: ${x || window.innerWidth / 2 - 50}px;
          top: ${y || window.innerHeight / 2 - 100}px;
          color: ${color};
          font-size: 24px;
          font-weight: bold;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
          pointer-events: none;
          z-index: 10001;
          animation: floatUp 2s ease-out forwards;
        `;

        // Add floating animation
        const style = document.createElement("style");
        style.textContent = `
          @keyframes floatUp {
            0% { 
              opacity: 1; 
              transform: translateY(0px) scale(1); 
            }
            50% { 
              opacity: 1; 
              transform: translateY(-30px) scale(1.1); 
            }
            100% { 
              opacity: 0; 
              transform: translateY(-60px) scale(0.8); 
            }
          }
        `;
        document.head.appendChild(style);
        document.body.appendChild(floatingText);

        // Remove after animation
        setTimeout(() => {
          if (floatingText.parentNode) {
            floatingText.parentNode.removeChild(floatingText);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
        }, 2000);
      }

      function showMultiplierEffect(multiplier) {
        // Implement multiplier effect logic
        console.log(`Multiplier effect: ${multiplier}x`);
      }

      // Sync game state with server
      async function syncGameState() {
        try {
          const state = loadGameState();

          // First, get latest data from server
          const getResponse = await fetch(`/api/user/${telegramUserId}`);
          if (getResponse.ok) {
            const serverData = await getResponse.json();
            if (serverData.success && serverData.data) {
              // Update local state with server data if server has newer lastRecover
              if (
                serverData.data.lastRecover &&
                serverData.data.lastRecover > (state.lastRecover || 0)
              ) {
                state.lastRecover = serverData.data.lastRecover;
                console.log(
                  "üîÑ Updated lastRecover from server:",
                  new Date(state.lastRecover)
                );
              }
            }
          }

          // Then sync current state to server
          const response = await fetch(`/api/sync/${telegramUserId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              level: state.level,
              hp: state.hp,
              coinCount: state.coinCount,
              lastRecover: state.lastRecover || Date.now(),
              lastZeroHP: state.lastZeroHP,
            }),
          });

          if (response.ok) {
            const result = await response.json();
            console.log("‚úÖ Game state synced successfully");

            // Update local state with any server corrections
            if (result.data) {
              if (result.data.ruby !== undefined)
                state.coinCount = result.data.ruby;
              if (result.data.level !== undefined)
                state.level = result.data.level;
              if (result.data.hp !== undefined) state.hp = result.data.hp;

              saveGameState(state);
              updateUI(state);
            }
          } else {
            console.warn("‚ö†Ô∏è Failed to sync game state");
          }
        } catch (error) {
          console.warn("‚ö†Ô∏è Error syncing game state:", error);
        }
      }

      // =====================
      // 11. Bottom Navigation Functions
      // =====================

      function setActiveNavItem(activeId) {
        // Remove active class from all nav items
        const navItems = document.querySelectorAll('.nav-item');
        navItems.forEach(item => {
          item.classList.remove('active');
        });

        // Add active class to the specified item
        const activeItem = document.getElementById(activeId);
        if (activeItem) {
          activeItem.classList.add('active');
          console.log(`üéØ Navigation active: ${activeId}`);
        }
      }

      function initializeBottomNavigation() {
        // Set earn as active by default
        setActiveNavItem('nav-earn');

        // Add click and touch handlers for navigation items
        const navItems = document.querySelectorAll('.nav-item');
        navItems.forEach(item => {
          const handleNavigation = function(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Handle navigation based on item
            switch(item.id) {
              case 'nav-earn':
                console.log('üìà Earn tab selected');
                // Already on earn page, no action needed
                setActiveNavItem('nav-earn');
                break;
              case 'nav-exchange':
                console.log('üîÑ Exchange tab selected - redirecting...');
                window.location.href = 'exchange.html';
                break;
              case 'nav-auto-earn':
                console.log('üöÄ Auto earn selected');
                toggleAutoEarn();
                break;
              case 'nav-point':
                console.log('üéØ Point tab selected');
                window.location.href = 'point.html';
                break;
              case 'nav-help':
                console.log('‚ùì Help tab selected');
                // Handle help action
                break;
            }
          };

          // Add both click and touch events
          item.addEventListener('click', handleNavigation);
          item.addEventListener('touchend', handleNavigation);
        });
        
        function handleNavigation(itemId) {
          // Handle navigation based on item
          switch(itemId) {
            case 'nav-earn':
              console.log('üìà Earn tab selected');
              // Already on earn page, no action needed
              setActiveNavItem('nav-earn');
              break;
            case 'nav-exchange':
              console.log('üîÑ Exchange tab selected - redirecting...');
              window.location.href = 'exchange.html';
              break;
            case 'nav-auto-earn':
              console.log('üöÄ Auto earn tab selected');
              toggleAutoEarn();
              break;
            case 'nav-point':
              console.log('üéØ Point tab selected');
              window.location.href = 'point.html';
              break;
            case 'nav-help':
              console.log('‚ùì Help tab selected');
              // Add help functionality here
              break;
          }
        }
      }

      // =====================
      // 10. Event Listeners
      // =====================

      // HP loss per tap by level
      const HP_LOSS_BY_LEVEL = [
        // Level 1-10
        24, 25, 26, 28, 29, 30, 31, 32, 34, 35,
        // Level 11-20  
        41, 42, 43, 45, 46, 47, 49, 50, 51, 53,
        // Level 21-30
        62, 64, 65, 67, 68, 70, 71, 73, 74, 76,
        // Level 31-40
        88, 89, 91, 93, 95, 96, 98, 100, 102, 103,
        // Level 41-49
        117, 119, 121, 123, 125, 127, 129, 131, 133,
        // Level 50 (Ruby level)
        24, // Default to level 1 value for ruby level
        // Level 51-60
        83, 165, 167, 169, 172, 174, 176, 179, 181, 183,
        // Level 61-70
        216, 219, 221, 224, 227, 230, 232, 235, 238, 240,
        // Level 71-100 (using progressive values)
        250, 260, 270, 280, 0, // 71-75 (75 is ruby)
        290, 300, 310, 320, 0, // 76-80 (80 is ruby)
        330, 340, 350, 360, 0, // 81-85 (85 is ruby)
        370, 380, 390, 400, 0, // 86-90 (90 is ruby)
        410, 420, 430, 440, 0, // 91-95 (95 is ruby)
        450, 460, 470, 0, 0    // 96-100 (99, 100 are ruby)
      ];

      // Get HP loss for a specific level
      function getHPLoss(level) {
        if (level <= 0 || level > HP_LOSS_BY_LEVEL.length) return 24; // Default
        const hpLoss = HP_LOSS_BY_LEVEL[level - 1];
        return hpLoss === 0 ? 24 : hpLoss; // Use default for ruby levels
      }

      // Special effects when HP reaches 0
      function triggerHPZeroEffects() {
        const characterContainer = document.querySelector(".character-container");
        if (!characterContainer) return;

        console.log("üíÄ Triggering HP=0 effects - character faint animation");

        // Play crash sound effect
        playCrashSound();

        // Add faint animation to character
        characterContainer.classList.add('faint');
        
        // Create HP zero overlay
        const overlay = document.createElement('div');
        overlay.className = 'hp-zero-overlay';
        document.body.appendChild(overlay);
        
        // Show "HP Depleted" message
        showHPDepletedMessage();
        
        // Create sad particles effect
        createSadParticles();
        
        // Clean up effects after animation
        setTimeout(() => {
          characterContainer.classList.remove('faint');
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        }, 3000);
      }

      // Show HP depleted message
      function showHPDepletedMessage() {
        const message = document.createElement('div');
        message.textContent = 'üíî HP Depleted! üíî';
        message.style.cssText = `
          position: fixed;
          top: 25%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 24px;
          font-weight: bold;
          color: #ff4444;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px #ff4444;
          z-index: 9999;
          pointer-events: none;
          animation: hpDepletedMessage 3s ease-out forwards;
          font-family: 'Gugi', sans-serif;
          border: 2px solid #ff4444;
          background: rgba(0,0,0,0.8);
          padding: 15px 25px;
          border-radius: 15px;
        `;

        // Add animation
        const style = document.createElement('style');
        style.textContent = `
          @keyframes hpDepletedMessage {
            0% { 
              transform: translate(-50%, -50%) scale(0.5); 
              opacity: 0; 
            }
            20% { 
              transform: translate(-50%, -50%) scale(1.1); 
              opacity: 1; 
            }
            80% { 
              transform: translate(-50%, -50%) scale(1); 
              opacity: 1; 
            }
            100% { 
              transform: translate(-50%, -50%) scale(0.8) translateY(-30px); 
              opacity: 0; 
            }
          }
        `;
        document.head.appendChild(style);
        document.body.appendChild(message);

        // Clean up after animation
        setTimeout(() => {
          if (message.parentNode) {
            message.parentNode.removeChild(message);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
        }, 3000);
      }

      // Create sad particles (blue/gray) when HP reaches 0
      function createSadParticles() {
        const characterContainer = document.querySelector(".character-container");
        if (!characterContainer) return;

        const particleContainer = document.createElement('div');
        particleContainer.className = 'character-particles';
        
        // Create sad particles (tears effect)
        for (let i = 0; i < 6; i++) {
          const particle = document.createElement('div');
          particle.style.cssText = `
            position: absolute;
            width: 4px;
            height: 8px;
            background: linear-gradient(180deg, #87CEEB 0%, #4682B4 100%);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            opacity: 0;
            animation: tearDrop 2s ease-out forwards;
          `;
          
          // Random position around character's face area
          particle.style.left = (45 + Math.random() * 10) + '%';
          particle.style.top = (30 + Math.random() * 20) + '%';
          
          // Set animation delay
          particle.style.animationDelay = (i * 0.3) + 's';
          
          particleContainer.appendChild(particle);
        }
        
        // Add tear drop animation
        const style = document.createElement('style');
        style.textContent = `
          @keyframes tearDrop {
            0% {
              transform: translateY(0px);
              opacity: 0;
            }
            20% {
              opacity: 0.8;
            }
            100% {
              transform: translateY(60px);
              opacity: 0;
            }
          }
        `;
        document.head.appendChild(style);
        
        characterContainer.appendChild(particleContainer);
        
        // Clean up after animation
        setTimeout(() => {
          if (particleContainer.parentNode) {
            particleContainer.parentNode.removeChild(particleContainer);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
        }, 3000);
      }

      // =====================
      // Enhanced Data Persistence - REMOVED (Server API only)
      // =====================
      
      // Periodic server sync every 30 seconds
      setInterval(() => {
        if (window.currentGameState && telegramUserId) {
          syncGameStateToServer(window.currentGameState);
          console.log("üîÑ Auto-sync to server completed");
        }
      }, 30000);
      
      // Sync on page visibility change (when user switches tabs/apps)
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden' && window.currentGameState && telegramUserId) {
          syncGameStateToServer(window.currentGameState);
          console.log("üíæ Synced to server on visibility change");
        }
      });
      
      // Sync before page unload
      window.addEventListener('beforeunload', () => {
        if (window.currentGameState && telegramUserId) {
          syncGameStateToServer(window.currentGameState);
          console.log("üíæ Synced to server before page unload");
        }
      });
      
      console.log("üõ°Ô∏è Server-only data persistence initialized");
      
      // =====================
      // DEBUG COMMANDS - Available in console
      // =====================
      
      // Debug command to check current game state
      window.debugGameState = function() {
        console.log('=== CURRENT GAME STATE ===');
        console.log('Window state:', window.currentGameState);
        console.log('Telegram User ID:', window.telegramUserId);
        console.log('========================');
      };
      
      // Debug command to force sync to server
      window.debugForceSync = function() {
        if (window.currentGameState && window.telegramUserId) {
          console.log('üîÑ FORCE SYNCING to server...');
          console.log('Data being synced:', window.currentGameState);
          syncGameStateToServer(window.currentGameState);
        } else {
          console.log('‚ùå Cannot sync - missing game state or user ID');
        }
      };
      
      // Debug command to add coins manually (for testing)
      window.debugAddCoins = function(amount = 100) {
        if (window.currentGameState) {
          window.currentGameState.coinCount += amount;
          console.log(`‚úÖ Added ${amount} coins. New total: ${window.currentGameState.coinCount}`);
          updateUI(window.currentGameState);
          // Auto-sync to server
          if (window.telegramUserId) {
            syncGameStateToServer(window.currentGameState);
          }
        } else {
          console.log('‚ùå No game state available');
        }
      };
      
      // Debug command to reload from server
      window.debugReloadFromServer = function() {
        console.log('üîÑ Reloading from server...');
        loadGameStateFromServer().then(serverState => {
          if (serverState) {
            console.log('‚úÖ Server state loaded:', serverState);
            window.currentGameState = serverState;
            updateUI(serverState);
          } else {
            console.log('‚ùå Failed to load from server');
          }
        });
      };

      console.log("üîß DEBUG COMMANDS AVAILABLE:");
      console.log("- debugGameState() - Check current game state");
      console.log("- debugForceSync() - Force sync to server");
      console.log("- debugAddCoins(amount) - Add coins for testing");
      console.log("- debugReloadFromServer() - Reload from server");

      // =====================
      // Page Visibility and Focus Handlers for Server Updates
      // =====================
      
      // Reload from server when user returns to page (e.g., from exchange)
      document.addEventListener('visibilitychange', async function() {
        if (!document.hidden && telegramUserId) {
          console.log("üëÅÔ∏è Page became visible - checking for server updates for user:", telegramUserId);
          
          try {
            const serverState = await loadGameStateFromServer();
            if (serverState && window.currentGameState) {
              const serverCoins = serverState.coinCount || 0;
              const localCoins = window.currentGameState.coinCount || 0;
              
              
              if (serverCoins !== localCoins) {
                console.log(`üîÑ Ruby updated on server: ${localCoins} ‚Üí ${serverCoins}`);
                console.log("‚úÖ Updating UI with latest server data");
                
                // Update current state and UI
                window.currentGameState = serverState;
                updateUI(serverState);
                
                // Show notification about the update
                showFloatingText(`Ruby Updated: ${serverCoins.toLocaleString()}`, "#FFD93D");
              }
            }
          } catch (error) {
            console.warn("‚ö†Ô∏è Error checking server updates:", error);
          }
        }
      });
      
      // Also handle window focus events as backup
      window.addEventListener('focus', async function() {
        if (telegramUserId && !telegramUserId.startsWith("demo_")) {
          console.log("üéØ Window focused - checking for server updates...");
          
          try {
            const serverState = await loadGameStateFromServer();
            if (serverState && window.currentGameState) {
              const serverCoins = serverState.coinCount || 0;
              const localCoins = window.currentGameState.coinCount || 0;
              
              if (serverCoins !== localCoins) {
                console.log(`üîÑ Ruby updated on server: ${localCoins} ‚Üí ${serverCoins}`);
                console.log("‚úÖ Updating UI with latest server data");
                
                // Update current state and UI
                window.currentGameState = serverState;
                updateUI(serverState);
              }
            }
          } catch (error) {
            console.warn("‚ö†Ô∏è Error checking server updates:", error);
          }
        }
      });
    </script>
    
    <!-- Auto Earn Shared Functionality -->
    <script src="js/auto-earn-shared.js"></script>
  </body>
</html>
